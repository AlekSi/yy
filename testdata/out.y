// CAUTION: Generated by yy - DO NOT EDIT.

%{
// Copyright 2015 The gc Authors. All rights reserved.  Use of this source code
// is governed by a BSD-style license that can be found in the LICENSE file.

// This is a derived work, the original is published at
//
//        https://github.com/golang/go/blob/release-branch.go1.4/src/cmd/gc/go.y
//
// The original work is
//
// Copyright 2009 The Go Authors. All rights reserved.  Use of this source code
// is governed by a BSD-style license that can be found in the GO-LICENSE file.

package gc

import (
        "github.com/cznic/xc"
)
%}

%union {
	node  Node
	Token xc.Token
}

%token	<Token>
	'!'
	'%'
	'&'
	'('
	')'
	'*'
	'+'
	','
	'-'
	'.'
	'/'
	':'
	';'
	'<'
	'='
	'>'
	'['
	']'
	'^'
	'{'
	'|'
	'}'
	ADD_ASSIGN     "+="
	ANDAND         "&&"
	ANDNOT         "&^"
	ANDNOT_ASSIGN  "&^="
	AND_ASSIGN     "&="
	BODY           "{"
	BREAK          "break"
	CASE           "case"
	CHAN           "chan"
	CHANCOMM       "chan<-"
	CHAR_LIT       "rune literal"
	COLAS          ":="
	COMM           "<-"
	COMMCHAN       "<-chan"
	CONST          "const"
	CONTINUE       "continue"
	DDD            "..."
	DEC            "--"
	DEFAULT        "default"
	DEFER          "defer"
	DIV_ASSIGN     "/="
	ELSE           "else"
	EQ             "=="
	ERRCHECK
	ERROR
	FALLTHROUGH    "fallthrough"
	FLOAT_LIT      "floating-point literal"
	FOR            "for"
	FUNC           "func"
	GEQ            ">="
	GO             "go"
	GOTO           "goto"
	IDENTIFIER     "identifier"
	IF             "if"
	IMAG_LIT       "imaginary literal"
	IMPORT         "import"
	INC            "++"
	INTERFACE      "interface"
	INT_LIT        "integer literal"
	LEQ            "<="
	LSH            "<<"
	LSH_ASSIGN     "<<="
	MAP            "map"
	MOD_ASSIGN     "%="
	MUL_ASSIGN     "*="
	NEQ            "!="
	NO_PACKAGE
	NO_RESULT
	OROR           "||"
	OR_ASSIGN      "|="
	PACKAGE        "package"
	RANGE          "range"
	RETURN         "return"
	RSH            ">>"
	RSH_ASSIGN     ">>="
	SELECT         "select"
	STRING_LIT     "string literal"
	STRUCT         "struct"
	SUB_ASSIGN     "-="
	SWITCH         "switch"
	TYPE           "type"
	VAR            "var"
	XOR_ASSIGN     "^="

%type	<node>
	Argument
	ArgumentList
	ArrayType
	Assignment
	BasicLiteral
	Block
	BlockOpt
	Body
	Call
	ChanType
	CommaOpt
	CompLitItem
	CompLitItemList
	CompLitType
	CompLitValue
	ConstDecl
	ConstSpec
	ConstSpecList
	Elif
	ElifList
	Else
	Expression
	ExpressionList
	ExpressionListOpt
	ExpressionOpt
	File
	ForHeader
	ForStatement
	FuncDecl
	FuncOrMethod
	FuncType
	IdentifierList
	IdentifierOpt
	IfHeader
	IfStatement
	ImportDecl
	ImportList
	ImportPath
	ImportSpec
	ImportSpecList
	InterfaceMethodDecl
	InterfaceMethodDeclList
	InterfaceType
	LBrace
	LBraceCompLitItem
	LBraceCompLitItemList
	LBraceCompLitValue
	MapType
	Operand
	ParameterDecl
	ParameterDeclList
	Parameters
	PrimaryExpression
	Prologue
	QualifiedIdent
	Range
	ReceiverOpt
	ResultOpt
	SelectStatement
	SemicolonOpt
	Signature
	SimpleStatement
	SimpleStatementOpt
	SliceType
	Statement
	StatementList
	StatementNonDecl
	StringLitOpt
	StructFieldDecl
	StructFieldDeclList
	StructType
	SwitchBody
	SwitchCase
	SwitchCaseBlock
	SwitchCaseList
	SwitchStatement
	TopLevelDecl
	TopLevelDeclList
	Type
	TypeDecl
	TypeLiteral
	TypeSpec
	TypeSpecList
	UnaryExpression
	VarDecl
	VarSpec
	VarSpecList

%left	COMM
%left	OROR
%left	ANDAND
%left	EQ NEQ '<' LEQ '>' GEQ
%left	'+' '-' '|' '^'
%left	'*' '/' '%' LSH RSH '&' ANDNOT
%precedence	NO_RESULT
%precedence	'('
%precedence	TYPE
%precedence	')'

%start File

%%

File:
	Prologue TopLevelDeclList
	{
		$$ = &File{
			Prologue:          $1.(*Prologue),
			TopLevelDeclList:  $2.(*TopLevelDeclList).reverse(),
		}
	}

Argument:
	Expression
	{
		$$ = &Argument{
			Expression:  $1.(*Expression),
		}
	}
|	TypeLiteral
	{
		$$ = &Argument{
			Case:         1,
			TypeLiteral:  $1.(*TypeLiteral),
		}
	}

ArgumentList:
	Argument
	{
		$$ = &ArgumentList{
			Argument:  $1.(*Argument),
		}
	}
|	ArgumentList ',' Argument
	{
		$$ = &ArgumentList{
			Case:          1,
			ArgumentList:  $1.(*ArgumentList),
			Token:         $2,
			Argument:      $3.(*Argument),
		}
	}

ArrayType:
	'[' "..." ']' Type
	{
		$$ = &ArrayType{
			Token:   $1,
			Token2:  $2,
			Token3:  $3,
			Type:    $4.(*Type),
		}
	}
|	'[' Expression ']' Type
	{
		$$ = &ArrayType{
			Case:        1,
			Token:       $1,
			Expression:  $2.(*Expression),
			Token2:      $3,
			Type:        $4.(*Type),
		}
	}

Assignment:
	ExpressionList '=' ExpressionList
	{
		$$ = &Assignment{
			ExpressionList:   $1.(*ExpressionList).reverse(),
			Token:            $2,
			ExpressionList2:  $3.(*ExpressionList).reverse(),
		}
	}
|	ExpressionList "+=" ExpressionList
	{
		$$ = &Assignment{
			Case:             1,
			ExpressionList:   $1.(*ExpressionList).reverse(),
			Token:            $2,
			ExpressionList2:  $3.(*ExpressionList).reverse(),
		}
	}
|	ExpressionList "&^=" ExpressionList
	{
		$$ = &Assignment{
			Case:             2,
			ExpressionList:   $1.(*ExpressionList).reverse(),
			Token:            $2,
			ExpressionList2:  $3.(*ExpressionList).reverse(),
		}
	}
|	ExpressionList "&=" ExpressionList
	{
		$$ = &Assignment{
			Case:             3,
			ExpressionList:   $1.(*ExpressionList).reverse(),
			Token:            $2,
			ExpressionList2:  $3.(*ExpressionList).reverse(),
		}
	}
|	ExpressionList "/=" ExpressionList
	{
		$$ = &Assignment{
			Case:             4,
			ExpressionList:   $1.(*ExpressionList).reverse(),
			Token:            $2,
			ExpressionList2:  $3.(*ExpressionList).reverse(),
		}
	}
|	ExpressionList "<<=" ExpressionList
	{
		$$ = &Assignment{
			Case:             5,
			ExpressionList:   $1.(*ExpressionList).reverse(),
			Token:            $2,
			ExpressionList2:  $3.(*ExpressionList).reverse(),
		}
	}
|	ExpressionList "%=" ExpressionList
	{
		$$ = &Assignment{
			Case:             6,
			ExpressionList:   $1.(*ExpressionList).reverse(),
			Token:            $2,
			ExpressionList2:  $3.(*ExpressionList).reverse(),
		}
	}
|	ExpressionList "*=" ExpressionList
	{
		$$ = &Assignment{
			Case:             7,
			ExpressionList:   $1.(*ExpressionList).reverse(),
			Token:            $2,
			ExpressionList2:  $3.(*ExpressionList).reverse(),
		}
	}
|	ExpressionList "|=" ExpressionList
	{
		$$ = &Assignment{
			Case:             8,
			ExpressionList:   $1.(*ExpressionList).reverse(),
			Token:            $2,
			ExpressionList2:  $3.(*ExpressionList).reverse(),
		}
	}
|	ExpressionList ">>=" ExpressionList
	{
		$$ = &Assignment{
			Case:             9,
			ExpressionList:   $1.(*ExpressionList).reverse(),
			Token:            $2,
			ExpressionList2:  $3.(*ExpressionList).reverse(),
		}
	}
|	ExpressionList "-=" ExpressionList
	{
		$$ = &Assignment{
			Case:             10,
			ExpressionList:   $1.(*ExpressionList).reverse(),
			Token:            $2,
			ExpressionList2:  $3.(*ExpressionList).reverse(),
		}
	}
|	ExpressionList "^=" ExpressionList
	{
		$$ = &Assignment{
			Case:             11,
			ExpressionList:   $1.(*ExpressionList).reverse(),
			Token:            $2,
			ExpressionList2:  $3.(*ExpressionList).reverse(),
		}
	}

BasicLiteral:
	CHAR_LIT
	{
		$$ = &BasicLiteral{
			Token:  $1,
		}
	}
|	FLOAT_LIT
	{
		$$ = &BasicLiteral{
			Case:   1,
			Token:  $1,
		}
	}
|	IMAG_LIT
	{
		$$ = &BasicLiteral{
			Case:   2,
			Token:  $1,
		}
	}
|	INT_LIT
	{
		$$ = &BasicLiteral{
			Case:   3,
			Token:  $1,
		}
	}
|	STRING_LIT
	{
		$$ = &BasicLiteral{
			Case:   4,
			Token:  $1,
		}
	}

Block:
	'{'
	{
		lx := yylex.(*lexer)
                lx.beginScope()
        }
	StatementList '}'
	{
		lx := yylex.(*lexer)
		lhs := &Block{
			Token:          $1,
			StatementList:  $3.(*StatementList).reverse(),
			Token2:         $4,
		}
		$$ = lhs
                lhs.scope = lx.scope
                lx.endScope()
        }

BlockOpt:
	/* empty */
	{
		$$ = (*BlockOpt)(nil)
	}
|	Block
	{
		$$ = &BlockOpt{
			Block:  $1.(*Block),
		}
	}

Body:
	BODY
	{
		lx := yylex.(*lexer)
                lx.beginScope()
        }
	StatementList '}'
	{
		lx := yylex.(*lexer)
		lhs := &Body{
			Token:          $1,
			StatementList:  $3.(*StatementList).reverse(),
			Token2:         $4,
		}
		$$ = lhs
                lhs.scope = lx.scope
                lx.endScope()
        }

Call:
	'(' ')'
	{
		$$ = &Call{
			Token:   $1,
			Token2:  $2,
		}
	}
|	'(' ArgumentList CommaOpt ')'
	{
		$$ = &Call{
			Case:          1,
			Token:         $1,
			ArgumentList:  $2.(*ArgumentList).reverse(),
			CommaOpt:      $3.(*CommaOpt),
			Token2:        $4,
		}
	}
|	'(' ArgumentList "..." CommaOpt ')'
	{
		$$ = &Call{
			Case:          2,
			Token:         $1,
			ArgumentList:  $2.(*ArgumentList).reverse(),
			Token2:        $3,
			CommaOpt:      $4.(*CommaOpt),
			Token3:        $5,
		}
	}

ChanType:
	"chan" Type
	{
		$$ = &ChanType{
			Token:  $1,
			Type:   $2.(*Type),
		}
	}
|	"chan<-" Type
	{
		$$ = &ChanType{
			Case:   1,
			Token:  $1,
			Type:   $2.(*Type),
		}
	}
|	"<-chan" Type
	{
		$$ = &ChanType{
			Case:   2,
			Token:  $1,
			Type:   $2.(*Type),
		}
	}

CommaOpt:
	/* empty */
	{
		$$ = (*CommaOpt)(nil)
	}
|	','
	{
		$$ = &CommaOpt{
			Token:  $1,
		}
	}

CompLitItem:
	Expression
	{
		$$ = &CompLitItem{
			Expression:  $1.(*Expression),
		}
	}
|	CompLitValue
	{
		$$ = &CompLitItem{
			Case:          1,
			CompLitValue:  $1.(*CompLitValue),
		}
	}
|	Expression ':' Expression
	{
		$$ = &CompLitItem{
			Case:         2,
			Expression:   $1.(*Expression),
			Token:        $2,
			Expression2:  $3.(*Expression),
		}
	}
|	Expression ':' CompLitValue
	{
		$$ = &CompLitItem{
			Case:          3,
			Expression:    $1.(*Expression),
			Token:         $2,
			CompLitValue:  $3.(*CompLitValue),
		}
	}

CompLitItemList:
	CompLitItem
	{
		$$ = &CompLitItemList{
			CompLitItem:  $1.(*CompLitItem),
		}
	}
|	CompLitItemList ',' CompLitItem
	{
		$$ = &CompLitItemList{
			Case:             1,
			CompLitItemList:  $1.(*CompLitItemList),
			Token:            $2,
			CompLitItem:      $3.(*CompLitItem),
		}
	}

CompLitType:
	ArrayType
	{
		$$ = &CompLitType{
			ArrayType:  $1.(*ArrayType),
		}
	}
|	MapType
	{
		$$ = &CompLitType{
			Case:     1,
			MapType:  $1.(*MapType),
		}
	}
|	SliceType
	{
		$$ = &CompLitType{
			Case:       2,
			SliceType:  $1.(*SliceType),
		}
	}
|	StructType
	{
		$$ = &CompLitType{
			Case:        3,
			StructType:  $1.(*StructType),
		}
	}

CompLitValue:
	'{' '}'
	{
		$$ = &CompLitValue{
			Token:   $1,
			Token2:  $2,
		}
	}
|	'{' CompLitItemList CommaOpt '}'
	{
		$$ = &CompLitValue{
			Case:             1,
			Token:            $1,
			CompLitItemList:  $2.(*CompLitItemList).reverse(),
			CommaOpt:         $3.(*CommaOpt),
			Token2:           $4,
		}
	}

ConstDecl:
	"const" '(' ')'
	{
		$$ = &ConstDecl{
			Token:   $1,
			Token2:  $2,
			Token3:  $3,
		}
	}
|	"const" '(' ConstSpecList SemicolonOpt ')'
	{
		$$ = &ConstDecl{
			Case:           1,
			Token:          $1,
			Token2:         $2,
			ConstSpecList:  $3.(*ConstSpecList).reverse(),
			SemicolonOpt:   $4.(*SemicolonOpt),
			Token3:         $5,
		}
	}
|	"const" ConstSpec
	{
		$$ = &ConstDecl{
			Case:       2,
			Token:      $1,
			ConstSpec:  $2.(*ConstSpec),
		}
	}

ConstSpec:
	IdentifierList
	{
		lx := yylex.(*lexer)
		lhs := &ConstSpec{
			IdentifierList:  $1.(*IdentifierList).reverse(),
		}
		$$ = lhs
                lhs.declare(lx.scope)
        }
|	IdentifierList '=' ExpressionList
	{
		lx := yylex.(*lexer)
		lhs := &ConstSpec{
			Case:            1,
			IdentifierList:  $1.(*IdentifierList).reverse(),
			Token:           $2,
			ExpressionList:  $3.(*ExpressionList).reverse(),
		}
		$$ = lhs
                lhs.declare(lx.scope)
        }
|	IdentifierList Type '=' ExpressionList
	{
		lx := yylex.(*lexer)
		lhs := &ConstSpec{
			Case:            2,
			IdentifierList:  $1.(*IdentifierList).reverse(),
			Type:            $2.(*Type),
			Token:           $3,
			ExpressionList:  $4.(*ExpressionList).reverse(),
		}
		$$ = lhs
                lhs.declare(lx.scope)
        }

ConstSpecList:
	ConstSpec
	{
		$$ = &ConstSpecList{
			ConstSpec:  $1.(*ConstSpec),
		}
	}
|	ConstSpecList ';' ConstSpec
	{
		$$ = &ConstSpecList{
			Case:           1,
			ConstSpecList:  $1.(*ConstSpecList),
			Token:          $2,
			ConstSpec:      $3.(*ConstSpec),
		}
	}

Elif:
	"else" "if"
	{
		lx := yylex.(*lexer)
                lx.beginScope()
        }
	IfHeader Body
	{
		lx := yylex.(*lexer)
		$$ = &Elif{
			Token:     $1,
			Token2:    $2,
			IfHeader:  $4.(*IfHeader),
			Body:      $5.(*Body),
		}
                lx.endScope()
        }

ElifList:
	/* empty */
	{
		$$ = (*ElifList)(nil)
	}
|	ElifList Elif
	{
		$$ = &ElifList{
			ElifList:  $1.(*ElifList),
			Elif:      $2.(*Elif),
		}
	}

Else:
	/* empty */
	{
		$$ = (*Else)(nil)
	}
|	"else" Block
	{
		$$ = &Else{
			Token:  $1,
			Block:  $2.(*Block),
		}
	}

Expression:
	UnaryExpression
	{
		$$ = &Expression{
			UnaryExpression:  $1.(*UnaryExpression),
		}
	}
|	Expression '%' Expression
	{
		$$ = &Expression{
			Case:         1,
			Expression:   $1.(*Expression),
			Token:        $2,
			Expression2:  $3.(*Expression),
		}
	}
|	Expression '&' Expression
	{
		$$ = &Expression{
			Case:         2,
			Expression:   $1.(*Expression),
			Token:        $2,
			Expression2:  $3.(*Expression),
		}
	}
|	Expression '*' Expression
	{
		$$ = &Expression{
			Case:         3,
			Expression:   $1.(*Expression),
			Token:        $2,
			Expression2:  $3.(*Expression),
		}
	}
|	Expression '+' Expression
	{
		$$ = &Expression{
			Case:         4,
			Expression:   $1.(*Expression),
			Token:        $2,
			Expression2:  $3.(*Expression),
		}
	}
|	Expression '-' Expression
	{
		$$ = &Expression{
			Case:         5,
			Expression:   $1.(*Expression),
			Token:        $2,
			Expression2:  $3.(*Expression),
		}
	}
|	Expression '/' Expression
	{
		$$ = &Expression{
			Case:         6,
			Expression:   $1.(*Expression),
			Token:        $2,
			Expression2:  $3.(*Expression),
		}
	}
|	Expression '<' Expression
	{
		$$ = &Expression{
			Case:         7,
			Expression:   $1.(*Expression),
			Token:        $2,
			Expression2:  $3.(*Expression),
		}
	}
|	Expression '>' Expression
	{
		$$ = &Expression{
			Case:         8,
			Expression:   $1.(*Expression),
			Token:        $2,
			Expression2:  $3.(*Expression),
		}
	}
|	Expression '^' Expression
	{
		$$ = &Expression{
			Case:         9,
			Expression:   $1.(*Expression),
			Token:        $2,
			Expression2:  $3.(*Expression),
		}
	}
|	Expression '|' Expression
	{
		$$ = &Expression{
			Case:         10,
			Expression:   $1.(*Expression),
			Token:        $2,
			Expression2:  $3.(*Expression),
		}
	}
|	Expression "&&" Expression
	{
		$$ = &Expression{
			Case:         11,
			Expression:   $1.(*Expression),
			Token:        $2,
			Expression2:  $3.(*Expression),
		}
	}
|	Expression "&^" Expression
	{
		$$ = &Expression{
			Case:         12,
			Expression:   $1.(*Expression),
			Token:        $2,
			Expression2:  $3.(*Expression),
		}
	}
|	Expression "==" Expression
	{
		$$ = &Expression{
			Case:         13,
			Expression:   $1.(*Expression),
			Token:        $2,
			Expression2:  $3.(*Expression),
		}
	}
|	Expression ">=" Expression
	{
		$$ = &Expression{
			Case:         14,
			Expression:   $1.(*Expression),
			Token:        $2,
			Expression2:  $3.(*Expression),
		}
	}
|	Expression "<=" Expression
	{
		$$ = &Expression{
			Case:         15,
			Expression:   $1.(*Expression),
			Token:        $2,
			Expression2:  $3.(*Expression),
		}
	}
|	Expression "<<" Expression
	{
		$$ = &Expression{
			Case:         16,
			Expression:   $1.(*Expression),
			Token:        $2,
			Expression2:  $3.(*Expression),
		}
	}
|	Expression "!=" Expression
	{
		$$ = &Expression{
			Case:         17,
			Expression:   $1.(*Expression),
			Token:        $2,
			Expression2:  $3.(*Expression),
		}
	}
|	Expression "||" Expression
	{
		$$ = &Expression{
			Case:         18,
			Expression:   $1.(*Expression),
			Token:        $2,
			Expression2:  $3.(*Expression),
		}
	}
|	Expression ">>" Expression
	{
		$$ = &Expression{
			Case:         19,
			Expression:   $1.(*Expression),
			Token:        $2,
			Expression2:  $3.(*Expression),
		}
	}
|	Expression "<-" Expression
	{
		$$ = &Expression{
			Case:         20,
			Expression:   $1.(*Expression),
			Token:        $2,
			Expression2:  $3.(*Expression),
		}
	}

ExpressionOpt:
	/* empty */
	{
		$$ = (*ExpressionOpt)(nil)
	}
|	Expression
	{
		$$ = &ExpressionOpt{
			Expression:  $1.(*Expression),
		}
	}

ExpressionList:
	Expression
	{
		$$ = &ExpressionList{
			Expression:  $1.(*Expression),
		}
	}
|	ExpressionList ',' Expression
	{
		$$ = &ExpressionList{
			Case:            1,
			ExpressionList:  $1.(*ExpressionList),
			Token:           $2,
			Expression:      $3.(*Expression),
		}
	}

ExpressionListOpt:
	/* empty */
	{
		$$ = (*ExpressionListOpt)(nil)
	}
|	ExpressionList
	{
		$$ = &ExpressionListOpt{
			ExpressionList:  $1.(*ExpressionList).reverse(),
		}
	}

ForHeader:
	Range
	{
		$$ = &ForHeader{
			Range:  $1.(*Range),
		}
	}
|	SimpleStatementOpt ';' SimpleStatementOpt ';' SimpleStatementOpt
	{
		$$ = &ForHeader{
			Case:                 1,
			SimpleStatementOpt:   $1.(*SimpleStatementOpt),
			Token:                $2,
			SimpleStatementOpt2:  $3.(*SimpleStatementOpt),
			Token2:               $4,
			SimpleStatementOpt3:  $5.(*SimpleStatementOpt),
		}
	}
|	SimpleStatementOpt
	{
		$$ = &ForHeader{
			Case:                2,
			SimpleStatementOpt:  $1.(*SimpleStatementOpt),
		}
	}

ForStatement:
	"for"
	{
		lx := yylex.(*lexer)
                lx.beginScope()
        }
	ForHeader Body
	{
		lx := yylex.(*lexer)
		$$ = &ForStatement{
			Token:      $1,
			ForHeader:  $3.(*ForHeader),
			Body:       $4.(*Body),
		}
                lx.endScope()
        }

FuncDecl:
	FuncOrMethod BlockOpt
	{
		lx := yylex.(*lexer)
		lhs := &FuncDecl{
			FuncOrMethod:  $1.(*FuncOrMethod),
			BlockOpt:      $2.(*BlockOpt),
		}
		$$ = lhs
                if b := lhs.BlockOpt; b != nil {
                        lhs.FuncOrMethod.Block = b.Block
                }
                if lx.injectScope != nil {
                        lx.endScope()
                }
        }

FuncOrMethod:
	"func" ReceiverOpt IDENTIFIER Signature
	{
		lx := yylex.(*lexer)
		lhs := &FuncOrMethod{
			Token:        $1,
			ReceiverOpt:  $2.(*ReceiverOpt),
			Token2:       $3,
			Signature:    $4.(*Signature),
		}
		$$ = lhs
                pkgScope := lx.scope.parent
                fnScope := lx.beginScope()
                lhs.declare(pkgScope, fnScope)
                lx.injectScope = fnScope
        }

FuncType:
	"func" Signature
	{
		$$ = &FuncType{
			Token:      $1,
			Signature:  $2.(*Signature),
		}
	}

IdentifierOpt:
	/* empty */
	{
		$$ = (*IdentifierOpt)(nil)
	}
|	IDENTIFIER
	{
		$$ = &IdentifierOpt{
			Token:  $1,
		}
	}

IdentifierList:
	IDENTIFIER
	{
		$$ = &IdentifierList{
			Token:  $1,
		}
	}
|	IdentifierList ',' IDENTIFIER
	{
		$$ = &IdentifierList{
			Case:            1,
			IdentifierList:  $1.(*IdentifierList),
			Token:           $2,
			Token2:          $3,
		}
	}

IfHeader:
	SimpleStatementOpt
	{
		$$ = &IfHeader{
			SimpleStatementOpt:  $1.(*SimpleStatementOpt),
		}
	}
|	SimpleStatementOpt ';' SimpleStatementOpt
	{
		$$ = &IfHeader{
			Case:                 1,
			SimpleStatementOpt:   $1.(*SimpleStatementOpt),
			Token:                $2,
			SimpleStatementOpt2:  $3.(*SimpleStatementOpt),
		}
	}

IfStatement:
	"if"
	{
		lx := yylex.(*lexer)
                lx.beginScope()
        }
	IfHeader Body ElifList Else
	{
		lx := yylex.(*lexer)
		$$ = &IfStatement{
			Token:     $1,
			IfHeader:  $3.(*IfHeader),
			Body:      $4.(*Body),
			ElifList:  $5.(*ElifList).reverse(),
			Else:      $6.(*Else),
		}
                lx.endScope()
        }

ImportDecl:
	"import" '(' ')'
	{
		$$ = &ImportDecl{
			Token:   $1,
			Token2:  $2,
			Token3:  $3,
		}
	}
|	"import" '(' ImportSpecList SemicolonOpt ')'
	{
		$$ = &ImportDecl{
			Case:            1,
			Token:           $1,
			Token2:          $2,
			ImportSpecList:  $3.(*ImportSpecList).reverse(),
			SemicolonOpt:    $4.(*SemicolonOpt),
			Token3:          $5,
		}
	}
|	"import" ImportSpec
	{
		$$ = &ImportDecl{
			Case:        2,
			Token:       $1,
			ImportSpec:  $2.(*ImportSpec),
		}
	}

ImportPath:
	BasicLiteral
	{
		lx := yylex.(*lexer)
		lhs := &ImportPath{
			BasicLiteral:  $1.(*BasicLiteral),
		}
		$$ = lhs
                lhs.process(lx)
        }

ImportSpec:
	'.' ImportPath
	{
		$$ = &ImportSpec{
			Token:       $1,
			ImportPath:  $2.(*ImportPath),
		}
	}
|	IdentifierOpt ImportPath
	{
		$$ = &ImportSpec{
			Case:           1,
			IdentifierOpt:  $1.(*IdentifierOpt),
			ImportPath:     $2.(*ImportPath),
		}
	}

ImportSpecList:
	ImportSpec
	{
		$$ = &ImportSpecList{
			ImportSpec:  $1.(*ImportSpec),
		}
	}
|	ImportSpecList ';' ImportSpec
	{
		$$ = &ImportSpecList{
			Case:            1,
			ImportSpecList:  $1.(*ImportSpecList),
			Token:           $2,
			ImportSpec:      $3.(*ImportSpec),
		}
	}

ImportList:
	/* empty */
	{
		$$ = (*ImportList)(nil)
	}
|	ImportList ImportDecl ';'
	{
		$$ = &ImportList{
			ImportList:  $1.(*ImportList),
			ImportDecl:  $2.(*ImportDecl),
			Token:       $3,
		}
	}

InterfaceType:
	"interface" LBrace '}'
	{
		$$ = &InterfaceType{
			Token:   $1,
			LBrace:  $2.(*LBrace),
			Token2:  $3,
		}
	}
|	"interface" LBrace InterfaceMethodDeclList SemicolonOpt '}'
	{
		$$ = &InterfaceType{
			Case:                     1,
			Token:                    $1,
			LBrace:                   $2.(*LBrace),
			InterfaceMethodDeclList:  $3.(*InterfaceMethodDeclList).reverse(),
			SemicolonOpt:             $4.(*SemicolonOpt),
			Token2:                   $5,
		}
	}

InterfaceMethodDecl:
	IDENTIFIER Signature
	{
		$$ = &InterfaceMethodDecl{
			Token:      $1,
			Signature:  $2.(*Signature),
		}
	}
|	QualifiedIdent
	{
		$$ = &InterfaceMethodDecl{
			Case:            1,
			QualifiedIdent:  $1.(*QualifiedIdent),
		}
	}

InterfaceMethodDeclList:
	InterfaceMethodDecl
	{
		$$ = &InterfaceMethodDeclList{
			InterfaceMethodDecl:  $1.(*InterfaceMethodDecl),
		}
	}
|	InterfaceMethodDeclList ';' InterfaceMethodDecl
	{
		$$ = &InterfaceMethodDeclList{
			Case:                     1,
			InterfaceMethodDeclList:  $1.(*InterfaceMethodDeclList),
			Token:                    $2,
			InterfaceMethodDecl:      $3.(*InterfaceMethodDecl),
		}
	}

LBrace:
	BODY
	{
		lx := yylex.(*lexer)
		$$ = &LBrace{
			Token:  $1,
		}
                lx.fixLBR()
        }
|	'{'
	{
		$$ = &LBrace{
			Case:   1,
			Token:  $1,
		}
	}

LBraceCompLitItem:
	Expression
	{
		$$ = &LBraceCompLitItem{
			Expression:  $1.(*Expression),
		}
	}
|	Expression ':' Expression
	{
		$$ = &LBraceCompLitItem{
			Case:         1,
			Expression:   $1.(*Expression),
			Token:        $2,
			Expression2:  $3.(*Expression),
		}
	}
|	Expression ':' LBraceCompLitValue
	{
		$$ = &LBraceCompLitItem{
			Case:                2,
			Expression:          $1.(*Expression),
			Token:               $2,
			LBraceCompLitValue:  $3.(*LBraceCompLitValue),
		}
	}
|	LBraceCompLitValue
	{
		$$ = &LBraceCompLitItem{
			Case:                3,
			LBraceCompLitValue:  $1.(*LBraceCompLitValue),
		}
	}

LBraceCompLitItemList:
	LBraceCompLitItem
	{
		$$ = &LBraceCompLitItemList{
			LBraceCompLitItem:  $1.(*LBraceCompLitItem),
		}
	}
|	LBraceCompLitItemList ',' LBraceCompLitItem
	{
		$$ = &LBraceCompLitItemList{
			Case:                   1,
			LBraceCompLitItemList:  $1.(*LBraceCompLitItemList),
			Token:                  $2,
			LBraceCompLitItem:      $3.(*LBraceCompLitItem),
		}
	}

LBraceCompLitValue:
	LBrace '}'
	{
		$$ = &LBraceCompLitValue{
			LBrace:  $1.(*LBrace),
			Token:   $2,
		}
	}
|	LBrace LBraceCompLitItemList CommaOpt '}'
	{
		$$ = &LBraceCompLitValue{
			Case:                   1,
			LBrace:                 $1.(*LBrace),
			LBraceCompLitItemList:  $2.(*LBraceCompLitItemList).reverse(),
			CommaOpt:               $3.(*CommaOpt),
			Token:                  $4,
		}
	}

MapType:
	"map" '[' Type ']' Type
	{
		$$ = &MapType{
			Token:   $1,
			Token2:  $2,
			Type:    $3.(*Type),
			Token3:  $4,
			Type2:   $5.(*Type),
		}
	}

QualifiedIdent:
	IDENTIFIER
	{
		$$ = &QualifiedIdent{
			Token:  $1,
		}
	}
|	IDENTIFIER '.' IDENTIFIER
	{
		$$ = &QualifiedIdent{
			Case:    1,
			Token:   $1,
			Token2:  $2,
			Token3:  $3,
		}
	}

Operand:
	'(' Expression ')'
	{
		$$ = &Operand{
			Token:       $1,
			Expression:  $2.(*Expression),
			Token2:      $3,
		}
	}
|	'(' TypeLiteral ')'
	{
		$$ = &Operand{
			Case:         1,
			Token:        $1,
			TypeLiteral:  $2.(*TypeLiteral),
			Token2:       $3,
		}
	}
|	BasicLiteral
	{
		$$ = &Operand{
			Case:          2,
			BasicLiteral:  $1.(*BasicLiteral),
		}
	}
|	FuncType LBrace
	{
		lx := yylex.(*lexer)
                lx.beginScope()
        }
	StatementList '}'
	{
		lx := yylex.(*lexer)
		$$ = &Operand{
			Case:           3,
			FuncType:       $1.(*FuncType),
			LBrace:         $2.(*LBrace),
			StatementList:  $4.(*StatementList).reverse(),
			Token:          $5,
		}
                lx.endScope()
        }
|	FuncType error
	{
		$$ = &Operand{
			Case:      4,
			FuncType:  $1.(*FuncType),
		}
	}
|	IDENTIFIER
	{
		$$ = &Operand{
			Case:   5,
			Token:  $1,
		}
	}

ParameterDecl:
	"..." Type
	{
		$$ = &ParameterDecl{
			Token:  $1,
			Type:   $2.(*Type),
		}
	}
|	IDENTIFIER "..." Type
	{
		$$ = &ParameterDecl{
			Case:    1,
			Token:   $1,
			Token2:  $2,
			Type:    $3.(*Type),
		}
	}
|	IDENTIFIER Type
	{
		$$ = &ParameterDecl{
			Case:   2,
			Token:  $1,
			Type:   $2.(*Type),
		}
	}
|	Type %prec TYPE
	{
		$$ = &ParameterDecl{
			Case:  3,
			Type:  $1.(*Type),
		}
	}

ParameterDeclList:
	ParameterDecl
	{
		$$ = &ParameterDeclList{
			ParameterDecl:  $1.(*ParameterDecl),
		}
	}
|	ParameterDeclList ',' ParameterDecl
	{
		$$ = &ParameterDeclList{
			Case:               1,
			ParameterDeclList:  $1.(*ParameterDeclList),
			Token:              $2,
			ParameterDecl:      $3.(*ParameterDecl),
		}
	}

Parameters:
	'(' ')'
	{
		$$ = &Parameters{
			Token:   $1,
			Token2:  $2,
		}
	}
|	'(' ParameterDeclList CommaOpt ')'
	{
		$$ = &Parameters{
			Case:               1,
			Token:              $1,
			ParameterDeclList:  $2.(*ParameterDeclList).reverse(),
			CommaOpt:           $3.(*CommaOpt),
			Token2:             $4,
		}
	}

PrimaryExpression:
	Operand
	{
		$$ = &PrimaryExpression{
			Operand:  $1.(*Operand),
		}
	}
|	CompLitType LBraceCompLitValue
	{
		$$ = &PrimaryExpression{
			Case:                1,
			CompLitType:         $1.(*CompLitType),
			LBraceCompLitValue:  $2.(*LBraceCompLitValue),
		}
	}
|	PrimaryExpression '.' '(' "type" ')'
	{
		$$ = &PrimaryExpression{
			Case:               2,
			PrimaryExpression:  $1.(*PrimaryExpression),
			Token:              $2,
			Token2:             $3,
			Token3:             $4,
			Token4:             $5,
		}
	}
|	PrimaryExpression '.' '(' Type ')'
	{
		$$ = &PrimaryExpression{
			Case:               3,
			PrimaryExpression:  $1.(*PrimaryExpression),
			Token:              $2,
			Token2:             $3,
			Type:               $4.(*Type),
			Token3:             $5,
		}
	}
|	PrimaryExpression '.' IDENTIFIER
	{
		$$ = &PrimaryExpression{
			Case:               4,
			PrimaryExpression:  $1.(*PrimaryExpression),
			Token:              $2,
			Token2:             $3,
		}
	}
|	PrimaryExpression '[' Expression ']'
	{
		$$ = &PrimaryExpression{
			Case:               5,
			PrimaryExpression:  $1.(*PrimaryExpression),
			Token:              $2,
			Expression:         $3.(*Expression),
			Token2:             $4,
		}
	}
|	PrimaryExpression '[' ExpressionOpt ':' ExpressionOpt ':' ExpressionOpt ']'
	{
		$$ = &PrimaryExpression{
			Case:               6,
			PrimaryExpression:  $1.(*PrimaryExpression),
			Token:              $2,
			ExpressionOpt:      $3.(*ExpressionOpt),
			Token2:             $4,
			ExpressionOpt2:     $5.(*ExpressionOpt),
			Token3:             $6,
			ExpressionOpt3:     $7.(*ExpressionOpt),
			Token4:             $8,
		}
	}
|	PrimaryExpression '[' ExpressionOpt ':' ExpressionOpt ']'
	{
		$$ = &PrimaryExpression{
			Case:               7,
			PrimaryExpression:  $1.(*PrimaryExpression),
			Token:              $2,
			ExpressionOpt:      $3.(*ExpressionOpt),
			Token2:             $4,
			ExpressionOpt2:     $5.(*ExpressionOpt),
			Token3:             $6,
		}
	}
|	PrimaryExpression Call
	{
		$$ = &PrimaryExpression{
			Case:               8,
			PrimaryExpression:  $1.(*PrimaryExpression),
			Call:               $2.(*Call),
		}
	}
|	PrimaryExpression CompLitValue
	{
		$$ = &PrimaryExpression{
			Case:               9,
			PrimaryExpression:  $1.(*PrimaryExpression),
			CompLitValue:       $2.(*CompLitValue),
		}
	}
|	TypeLiteral '(' Expression CommaOpt ')'
	{
		$$ = &PrimaryExpression{
			Case:         10,
			TypeLiteral:  $1.(*TypeLiteral),
			Token:        $2,
			Expression:   $3.(*Expression),
			CommaOpt:     $4.(*CommaOpt),
			Token2:       $5,
		}
	}

Prologue:
	"package" IDENTIFIER ';'
	{
		lx := yylex.(*lexer)
                if !lx.build { // Build constraints not satisfied.
                        goto ret0
                }

                if lx.main && $2.Val != idMain {
                        errTok($2, "cannot compile non-main package")
                        goto ret1
                }

                if lx.pkgName == 0 {
                        lx.pkgName = $2.Val
                        break
                }

                if $2.Val != lx.pkgName {
                        errTok($2, "expected package %%s", dict.S(lx.pkgName))
                        goto ret1
                }
        }
	ImportList
	{
		lx := yylex.(*lexer)
		lhs := &Prologue{
			Token:       $1,
			Token2:      $2,
			Token3:      $3,
			ImportList:  $5.(*ImportList).reverse(),
		}
		$$ = lhs
                lhs.declare(lx.scope)
        }
|	error
	{
		$$ = &Prologue{
			Case:  1,
		}
                return -NO_PACKAGE
        }

Range:
	ExpressionList '=' "range" Expression
	{
		$$ = &Range{
			ExpressionList:  $1.(*ExpressionList).reverse(),
			Token:           $2,
			Token2:          $3,
			Expression:      $4.(*Expression),
		}
	}
|	ExpressionList ":=" "range" Expression
	{
		$$ = &Range{
			Case:            1,
			ExpressionList:  $1.(*ExpressionList).reverse(),
			Token:           $2,
			Token2:          $3,
			Expression:      $4.(*Expression),
		}
	}
|	"range" Expression
	{
		$$ = &Range{
			Case:        2,
			Token:       $1,
			Expression:  $2.(*Expression),
		}
	}

ReceiverOpt:
	/* empty */
	{
		$$ = (*ReceiverOpt)(nil)
	}
|	Parameters
	{
		$$ = &ReceiverOpt{
			Parameters:  $1.(*Parameters),
		}
	}

ResultOpt:
	/* empty */ %prec NO_RESULT
	{
		$$ = (*ResultOpt)(nil)
	}
|	Parameters
	{
		$$ = &ResultOpt{
			Case:        1,
			Parameters:  $1.(*Parameters),
		}
	}
|	Type
	{
		$$ = &ResultOpt{
			Case:  2,
			Type:  $1.(*Type),
		}
	}

SelectStatement:
	"select" SwitchBody
	{
		$$ = &SelectStatement{
			Token:       $1,
			SwitchBody:  $2.(*SwitchBody),
		}
	}

SemicolonOpt:
	/* empty */
	{
		$$ = (*SemicolonOpt)(nil)
	}
|	';'
	{
		$$ = &SemicolonOpt{
			Token:  $1,
		}
	}

Signature:
	Parameters ResultOpt
	{
		$$ = &Signature{
			Parameters:  $1.(*Parameters),
			ResultOpt:   $2.(*ResultOpt),
		}
	}

SimpleStatement:
	Assignment
	{
		$$ = &SimpleStatement{
			Assignment:  $1.(*Assignment),
		}
	}
|	Expression
	{
		$$ = &SimpleStatement{
			Case:        1,
			Expression:  $1.(*Expression),
		}
	}
|	Expression "--"
	{
		$$ = &SimpleStatement{
			Case:        2,
			Expression:  $1.(*Expression),
			Token:       $2,
		}
	}
|	Expression "++"
	{
		$$ = &SimpleStatement{
			Case:        3,
			Expression:  $1.(*Expression),
			Token:       $2,
		}
	}
|	ExpressionList ":=" ExpressionList
	{
		$$ = &SimpleStatement{
			Case:             4,
			ExpressionList:   $1.(*ExpressionList).reverse(),
			Token:            $2,
			ExpressionList2:  $3.(*ExpressionList).reverse(),
		}
	}

SimpleStatementOpt:
	/* empty */
	{
		$$ = (*SimpleStatementOpt)(nil)
	}
|	SimpleStatement
	{
		$$ = &SimpleStatementOpt{
			SimpleStatement:  $1.(*SimpleStatement),
		}
	}

SliceType:
	'[' ']' Type
	{
		$$ = &SliceType{
			Token:   $1,
			Token2:  $2,
			Type:    $3.(*Type),
		}
	}

Statement:
	/* empty */
	{
		$$ = (*Statement)(nil)
	}
|	Block
	{
		$$ = &Statement{
			Case:   1,
			Block:  $1.(*Block),
		}
	}
|	ConstDecl
	{
		$$ = &Statement{
			Case:       2,
			ConstDecl:  $1.(*ConstDecl),
		}
	}
|	TypeDecl
	{
		$$ = &Statement{
			Case:      3,
			TypeDecl:  $1.(*TypeDecl),
		}
	}
|	VarDecl
	{
		$$ = &Statement{
			Case:     4,
			VarDecl:  $1.(*VarDecl),
		}
	}
|	StatementNonDecl
	{
		$$ = &Statement{
			Case:              5,
			StatementNonDecl:  $1.(*StatementNonDecl),
		}
	}

StatementList:
	Statement
	{
		$$ = &StatementList{
			Statement:  $1.(*Statement),
		}
	}
|	StatementList ';' Statement
	{
		$$ = &StatementList{
			Case:           1,
			StatementList:  $1.(*StatementList),
			Token:          $2,
			Statement:      $3.(*Statement),
		}
	}

StatementNonDecl:
	"break" IdentifierOpt
	{
		$$ = &StatementNonDecl{
			Token:          $1,
			IdentifierOpt:  $2.(*IdentifierOpt),
		}
	}
|	"continue" IdentifierOpt
	{
		$$ = &StatementNonDecl{
			Case:           1,
			Token:          $1,
			IdentifierOpt:  $2.(*IdentifierOpt),
		}
	}
|	"defer" Expression
	{
		$$ = &StatementNonDecl{
			Case:        2,
			Token:       $1,
			Expression:  $2.(*Expression),
		}
	}
|	"fallthrough"
	{
		$$ = &StatementNonDecl{
			Case:   3,
			Token:  $1,
		}
	}
|	ForStatement
	{
		$$ = &StatementNonDecl{
			Case:          4,
			ForStatement:  $1.(*ForStatement),
		}
	}
|	"go" Expression
	{
		$$ = &StatementNonDecl{
			Case:        5,
			Token:       $1,
			Expression:  $2.(*Expression),
		}
	}
|	"goto" IDENTIFIER
	{
		$$ = &StatementNonDecl{
			Case:    6,
			Token:   $1,
			Token2:  $2,
		}
	}
|	IDENTIFIER ':' Statement
	{
		$$ = &StatementNonDecl{
			Case:       7,
			Token:      $1,
			Token2:     $2,
			Statement:  $3.(*Statement),
		}
	}
|	IfStatement
	{
		$$ = &StatementNonDecl{
			Case:         8,
			IfStatement:  $1.(*IfStatement),
		}
	}
|	"return" ExpressionListOpt
	{
		$$ = &StatementNonDecl{
			Case:               9,
			Token:              $1,
			ExpressionListOpt:  $2.(*ExpressionListOpt),
		}
	}
|	SelectStatement
	{
		$$ = &StatementNonDecl{
			Case:             10,
			SelectStatement:  $1.(*SelectStatement),
		}
	}
|	SimpleStatement
	{
		$$ = &StatementNonDecl{
			Case:             11,
			SimpleStatement:  $1.(*SimpleStatement),
		}
	}
|	SwitchStatement
	{
		$$ = &StatementNonDecl{
			Case:             12,
			SwitchStatement:  $1.(*SwitchStatement),
		}
	}
|	error
	{
		$$ = &StatementNonDecl{
			Case:  13,
		}
	}

StringLitOpt:
	/* empty */
	{
		$$ = (*StringLitOpt)(nil)
	}
|	STRING_LIT
	{
		$$ = &StringLitOpt{
			Token:  $1,
		}
	}

StructFieldDecl:
	'*' QualifiedIdent StringLitOpt
	{
		$$ = &StructFieldDecl{
			Token:           $1,
			QualifiedIdent:  $2.(*QualifiedIdent),
			StringLitOpt:    $3.(*StringLitOpt),
		}
	}
|	IdentifierList Type StringLitOpt
	{
		$$ = &StructFieldDecl{
			Case:            1,
			IdentifierList:  $1.(*IdentifierList).reverse(),
			Type:            $2.(*Type),
			StringLitOpt:    $3.(*StringLitOpt),
		}
	}
|	QualifiedIdent StringLitOpt
	{
		$$ = &StructFieldDecl{
			Case:            2,
			QualifiedIdent:  $1.(*QualifiedIdent),
			StringLitOpt:    $2.(*StringLitOpt),
		}
	}
|	'(' QualifiedIdent ')' StringLitOpt
	{
		lhs := &StructFieldDecl{
			Case:            3,
			Token:           $1,
			QualifiedIdent:  $2.(*QualifiedIdent),
			Token2:          $3,
			StringLitOpt:    $4.(*StringLitOpt),
		}
		$$ = lhs
                errTok(lhs.QualifiedIdent.firstTok(), "cannot parenthesize embedded type")
        }
|	'(' '*' QualifiedIdent ')' StringLitOpt
	{
		lhs := &StructFieldDecl{
			Case:            4,
			Token:           $1,
			Token2:          $2,
			QualifiedIdent:  $3.(*QualifiedIdent),
			Token3:          $4,
			StringLitOpt:    $5.(*StringLitOpt),
		}
		$$ = lhs
                errTok(lhs.QualifiedIdent.firstTok(), "cannot parenthesize embedded type")
        }
|	'*' '(' QualifiedIdent ')' StringLitOpt
	{
		lhs := &StructFieldDecl{
			Case:            5,
			Token:           $1,
			Token2:          $2,
			QualifiedIdent:  $3.(*QualifiedIdent),
			Token3:          $4,
			StringLitOpt:    $5.(*StringLitOpt),
		}
		$$ = lhs
                errTok(lhs.QualifiedIdent.firstTok(), "cannot parenthesize embedded type")
        }

StructFieldDeclList:
	StructFieldDecl
	{
		$$ = &StructFieldDeclList{
			StructFieldDecl:  $1.(*StructFieldDecl),
		}
	}
|	StructFieldDeclList ';' StructFieldDecl
	{
		$$ = &StructFieldDeclList{
			Case:                 1,
			StructFieldDeclList:  $1.(*StructFieldDeclList),
			Token:                $2,
			StructFieldDecl:      $3.(*StructFieldDecl),
		}
	}

StructType:
	"struct" LBrace '}'
	{
		$$ = &StructType{
			Token:   $1,
			LBrace:  $2.(*LBrace),
			Token2:  $3,
		}
	}
|	"struct" LBrace StructFieldDeclList SemicolonOpt '}'
	{
		$$ = &StructType{
			Case:                 1,
			Token:                $1,
			LBrace:               $2.(*LBrace),
			StructFieldDeclList:  $3.(*StructFieldDeclList).reverse(),
			SemicolonOpt:         $4.(*SemicolonOpt),
			Token2:               $5,
		}
	}

SwitchBody:
	BODY '}'
	{
		$$ = &SwitchBody{
			Token:   $1,
			Token2:  $2,
		}
	}
|	BODY SwitchCaseList '}'
	{
		$$ = &SwitchBody{
			Case:            1,
			Token:           $1,
			SwitchCaseList:  $2.(*SwitchCaseList).reverse(),
			Token2:          $3,
		}
	}

SwitchCase:
	"case" ArgumentList ':'
	{
		$$ = &SwitchCase{
			Token:         $1,
			ArgumentList:  $2.(*ArgumentList).reverse(),
			Token2:        $3,
		}
	}
|	"case" ArgumentList '=' Expression ':'
	{
		$$ = &SwitchCase{
			Case:          1,
			Token:         $1,
			ArgumentList:  $2.(*ArgumentList).reverse(),
			Token2:        $3,
			Expression:    $4.(*Expression),
			Token3:        $5,
		}
	}
|	"case" ArgumentList ":=" Expression ':'
	{
		$$ = &SwitchCase{
			Case:          2,
			Token:         $1,
			ArgumentList:  $2.(*ArgumentList).reverse(),
			Token2:        $3,
			Expression:    $4.(*Expression),
			Token3:        $5,
		}
	}
|	"default" ':'
	{
		$$ = &SwitchCase{
			Case:    3,
			Token:   $1,
			Token2:  $2,
		}
	}

SwitchCaseBlock:
	SwitchCase
	{
		lx := yylex.(*lexer)
                lx.beginScope()
        }
	StatementList
	{
		lx := yylex.(*lexer)
		$$ = &SwitchCaseBlock{
			SwitchCase:     $1.(*SwitchCase),
			StatementList:  $3.(*StatementList).reverse(),
		}
                lx.endScope()
        }

SwitchCaseList:
	SwitchCaseBlock
	{
		$$ = &SwitchCaseList{
			SwitchCaseBlock:  $1.(*SwitchCaseBlock),
		}
	}
|	SwitchCaseList SwitchCaseBlock
	{
		$$ = &SwitchCaseList{
			Case:             1,
			SwitchCaseList:   $1.(*SwitchCaseList),
			SwitchCaseBlock:  $2.(*SwitchCaseBlock),
		}
	}

SwitchStatement:
	"switch"
	{
		lx := yylex.(*lexer)
                lx.beginScope()
        }
	IfHeader SwitchBody
	{
		lx := yylex.(*lexer)
		$$ = &SwitchStatement{
			Token:       $1,
			IfHeader:    $3.(*IfHeader),
			SwitchBody:  $4.(*SwitchBody),
		}
                lx.endScope()
        }

TopLevelDecl:
	ConstDecl
	{
		$$ = &TopLevelDecl{
			ConstDecl:  $1.(*ConstDecl),
		}
	}
|	FuncDecl
	{
		$$ = &TopLevelDecl{
			Case:      1,
			FuncDecl:  $1.(*FuncDecl),
		}
	}
|	TypeDecl
	{
		$$ = &TopLevelDecl{
			Case:      2,
			TypeDecl:  $1.(*TypeDecl),
		}
	}
|	VarDecl
	{
		$$ = &TopLevelDecl{
			Case:     3,
			VarDecl:  $1.(*VarDecl),
		}
	}
|	error
	{
		$$ = &TopLevelDecl{
			Case:  4,
		}
	}

TopLevelDeclList:
	/* empty */
	{
		$$ = (*TopLevelDeclList)(nil)
	}
|	TopLevelDeclList TopLevelDecl ';'
	{
		$$ = &TopLevelDeclList{
			TopLevelDeclList:  $1.(*TopLevelDeclList),
			TopLevelDecl:      $2.(*TopLevelDecl),
			Token:             $3,
		}
	}

Type:
	'(' Type ')'
	{
		$$ = &Type{
			Token:   $1,
			Type:    $2.(*Type),
			Token2:  $3,
		}
	}
|	'*' Type
	{
		$$ = &Type{
			Case:   1,
			Token:  $1,
			Type:   $2.(*Type),
		}
	}
|	ArrayType
	{
		$$ = &Type{
			Case:       2,
			ArrayType:  $1.(*ArrayType),
		}
	}
|	ChanType
	{
		$$ = &Type{
			Case:      3,
			ChanType:  $1.(*ChanType),
		}
	}
|	FuncType
	{
		$$ = &Type{
			Case:      4,
			FuncType:  $1.(*FuncType),
		}
	}
|	InterfaceType
	{
		$$ = &Type{
			Case:           5,
			InterfaceType:  $1.(*InterfaceType),
		}
	}
|	MapType
	{
		$$ = &Type{
			Case:     6,
			MapType:  $1.(*MapType),
		}
	}
|	QualifiedIdent
	{
		$$ = &Type{
			Case:            7,
			QualifiedIdent:  $1.(*QualifiedIdent),
		}
	}
|	SliceType
	{
		$$ = &Type{
			Case:       8,
			SliceType:  $1.(*SliceType),
		}
	}
|	StructType
	{
		$$ = &Type{
			Case:        9,
			StructType:  $1.(*StructType),
		}
	}

TypeDecl:
	"type" '(' ')'
	{
		$$ = &TypeDecl{
			Token:   $1,
			Token2:  $2,
			Token3:  $3,
		}
	}
|	"type" '(' TypeSpecList SemicolonOpt ')'
	{
		$$ = &TypeDecl{
			Case:          1,
			Token:         $1,
			Token2:        $2,
			TypeSpecList:  $3.(*TypeSpecList).reverse(),
			SemicolonOpt:  $4.(*SemicolonOpt),
			Token3:        $5,
		}
	}
|	"type" TypeSpec
	{
		$$ = &TypeDecl{
			Case:      2,
			Token:     $1,
			TypeSpec:  $2.(*TypeSpec),
		}
	}

TypeLiteral:
	'*' TypeLiteral
	{
		$$ = &TypeLiteral{
			Token:        $1,
			TypeLiteral:  $2.(*TypeLiteral),
		}
	}
|	ArrayType
	{
		$$ = &TypeLiteral{
			Case:       1,
			ArrayType:  $1.(*ArrayType),
		}
	}
|	ChanType
	{
		$$ = &TypeLiteral{
			Case:      2,
			ChanType:  $1.(*ChanType),
		}
	}
|	FuncType
	{
		$$ = &TypeLiteral{
			Case:      3,
			FuncType:  $1.(*FuncType),
		}
	}
|	InterfaceType
	{
		$$ = &TypeLiteral{
			Case:           4,
			InterfaceType:  $1.(*InterfaceType),
		}
	}
|	MapType
	{
		$$ = &TypeLiteral{
			Case:     5,
			MapType:  $1.(*MapType),
		}
	}
|	SliceType
	{
		$$ = &TypeLiteral{
			Case:       6,
			SliceType:  $1.(*SliceType),
		}
	}
|	StructType
	{
		$$ = &TypeLiteral{
			Case:        7,
			StructType:  $1.(*StructType),
		}
	}

TypeSpec:
	IDENTIFIER Type
	{
		lx := yylex.(*lexer)
		lhs := &TypeSpec{
			Token:  $1,
			Type:   $2.(*Type),
		}
		$$ = lhs
                lhs.declare(lx.scope)
        }

TypeSpecList:
	TypeSpec
	{
		$$ = &TypeSpecList{
			TypeSpec:  $1.(*TypeSpec),
		}
	}
|	TypeSpecList ';' TypeSpec
	{
		$$ = &TypeSpecList{
			Case:          1,
			TypeSpecList:  $1.(*TypeSpecList),
			Token:         $2,
			TypeSpec:      $3.(*TypeSpec),
		}
	}

UnaryExpression:
	'!' UnaryExpression
	{
		$$ = &UnaryExpression{
			Token:            $1,
			UnaryExpression:  $2.(*UnaryExpression),
		}
	}
|	'&' UnaryExpression
	{
		$$ = &UnaryExpression{
			Case:             1,
			Token:            $1,
			UnaryExpression:  $2.(*UnaryExpression),
		}
	}
|	'*' UnaryExpression
	{
		$$ = &UnaryExpression{
			Case:             2,
			Token:            $1,
			UnaryExpression:  $2.(*UnaryExpression),
		}
	}
|	'+' UnaryExpression
	{
		$$ = &UnaryExpression{
			Case:             3,
			Token:            $1,
			UnaryExpression:  $2.(*UnaryExpression),
		}
	}
|	'-' UnaryExpression
	{
		$$ = &UnaryExpression{
			Case:             4,
			Token:            $1,
			UnaryExpression:  $2.(*UnaryExpression),
		}
	}
|	'^' UnaryExpression
	{
		$$ = &UnaryExpression{
			Case:             5,
			Token:            $1,
			UnaryExpression:  $2.(*UnaryExpression),
		}
	}
|	"<-" UnaryExpression
	{
		$$ = &UnaryExpression{
			Case:             6,
			Token:            $1,
			UnaryExpression:  $2.(*UnaryExpression),
		}
	}
|	PrimaryExpression
	{
		$$ = &UnaryExpression{
			Case:               7,
			PrimaryExpression:  $1.(*PrimaryExpression),
		}
	}

VarDecl:
	"var" '(' ')'
	{
		$$ = &VarDecl{
			Token:   $1,
			Token2:  $2,
			Token3:  $3,
		}
	}
|	"var" '(' VarSpecList SemicolonOpt ')'
	{
		$$ = &VarDecl{
			Case:          1,
			Token:         $1,
			Token2:        $2,
			VarSpecList:   $3.(*VarSpecList).reverse(),
			SemicolonOpt:  $4.(*SemicolonOpt),
			Token3:        $5,
		}
	}
|	"var" VarSpec
	{
		$$ = &VarDecl{
			Case:     2,
			Token:    $1,
			VarSpec:  $2.(*VarSpec),
		}
	}

VarSpec:
	IdentifierList '=' ExpressionList
	{
		lx := yylex.(*lexer)
		lhs := &VarSpec{
			IdentifierList:  $1.(*IdentifierList).reverse(),
			Token:           $2,
			ExpressionList:  $3.(*ExpressionList).reverse(),
		}
		$$ = lhs
                lhs.declare(lx.scope)
        }
|	IdentifierList Type
	{
		lx := yylex.(*lexer)
		lhs := &VarSpec{
			Case:            1,
			IdentifierList:  $1.(*IdentifierList).reverse(),
			Type:            $2.(*Type),
		}
		$$ = lhs
                lhs.declare(lx.scope)
        }
|	IdentifierList Type '=' ExpressionList
	{
		lx := yylex.(*lexer)
		lhs := &VarSpec{
			Case:            2,
			IdentifierList:  $1.(*IdentifierList).reverse(),
			Type:            $2.(*Type),
			Token:           $3,
			ExpressionList:  $4.(*ExpressionList).reverse(),
		}
		$$ = lhs
                lhs.declare(lx.scope)
        }

VarSpecList:
	VarSpec
	{
		$$ = &VarSpecList{
			VarSpec:  $1.(*VarSpec),
		}
	}
|	VarSpecList ';' VarSpec
	{
		$$ = &VarSpecList{
			Case:         1,
			VarSpecList:  $1.(*VarSpecList),
			Token:        $2,
			VarSpec:      $3.(*VarSpec),
		}
	}
