// Code generated by yy. DO NOT EDIT.

// Copyright 2015 The gc Authors. All rights reserved.  Use of this source code
// is governed by a BSD-style license that can be found in the LICENSE file.

package gc

// Argument represents data reduced by productions:
//
//	Argument:
//	        Expression   // Case 0
//	|       TypeLiteral  // Case 1
type Argument struct {
	Case        int
	Expression  *Expression
	TypeLiteral *TypeLiteral
}

func (n *Argument) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *Argument) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *Argument) Pos() token.Pos {
	if n == nil {
		return 0
	}

	switch n.Case {
	case 0:
		return n.Expression.Pos()
	case 1:
		return n.TypeLiteral.Pos()
	default:
		panic("internal error")
	}
}

// ArgumentList represents data reduced by productions:
//
//	ArgumentList:
//	        Argument                   // Case 0
//	|       ArgumentList ',' Argument  // Case 1
type ArgumentList struct {
	Argument     *Argument
	ArgumentList *ArgumentList
	Case         int
	Token        xc.Token
}

func (n *ArgumentList) reverse() *ArgumentList {
	if n == nil {
		return nil
	}

	na := n
	nb := na.ArgumentList
	for nb != nil {
		nc := nb.ArgumentList
		nb.ArgumentList = na
		na = nb
		nb = nc
	}
	n.ArgumentList = nil
	return na
}

func (n *ArgumentList) fragment() interface{} { return n.reverse() }

// String implements fmt.Stringer.
func (n *ArgumentList) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *ArgumentList) Pos() token.Pos {
	if n == nil {
		return 0
	}

	switch n.Case {
	case 0:
		return n.Argument.Pos()
	case 1:
		return n.ArgumentList.Pos()
	default:
		panic("internal error")
	}
}

// ArrayType represents data reduced by productions:
//
//	ArrayType:
//	        '[' "..." ']' Type       // Case 0
//	|       '[' Expression ']' Type  // Case 1
type ArrayType struct {
	Case       int
	Expression *Expression
	Token      xc.Token
	Token2     xc.Token
	Token3     xc.Token
	Type       *Type
}

func (n *ArrayType) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *ArrayType) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *ArrayType) Pos() token.Pos {
	if n == nil {
		return 0
	}

	return n.Token.Pos()
}

// Assignment represents data reduced by productions:
//
//	Assignment:
//	        ExpressionList '=' ExpressionList    // Case 0
//	|       ExpressionList "+=" ExpressionList   // Case 1
//	|       ExpressionList "&^=" ExpressionList  // Case 2
//	|       ExpressionList "&=" ExpressionList   // Case 3
//	|       ExpressionList "/=" ExpressionList   // Case 4
//	|       ExpressionList "<<=" ExpressionList  // Case 5
//	|       ExpressionList "%=" ExpressionList   // Case 6
//	|       ExpressionList "*=" ExpressionList   // Case 7
//	|       ExpressionList "|=" ExpressionList   // Case 8
//	|       ExpressionList ">>=" ExpressionList  // Case 9
//	|       ExpressionList "-=" ExpressionList   // Case 10
//	|       ExpressionList "^=" ExpressionList   // Case 11
type Assignment struct {
	Case            int
	ExpressionList  *ExpressionList
	ExpressionList2 *ExpressionList
	Token           xc.Token
}

func (n *Assignment) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *Assignment) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *Assignment) Pos() token.Pos {
	if n == nil {
		return 0
	}

	return n.ExpressionList.Pos()
}

// BasicLiteral represents data reduced by productions:
//
//	BasicLiteral:
//	        CHAR_LIT    // Case 0
//	|       FLOAT_LIT   // Case 1
//	|       IMAG_LIT    // Case 2
//	|       INT_LIT     // Case 3
//	|       STRING_LIT  // Case 4
type BasicLiteral struct {
	Case  int
	Token xc.Token
}

func (n *BasicLiteral) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *BasicLiteral) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *BasicLiteral) Pos() token.Pos {
	if n == nil {
		return 0
	}

	return n.Token.Pos()
}

// Block represents data reduced by production:
//
//	Block:
//	        '{' StatementList '}'  // Case 0
type Block struct {
	scope         *Scope
	StatementList *StatementList
	Token         xc.Token
	Token2        xc.Token
}

func (n *Block) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *Block) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *Block) Pos() token.Pos {
	if n == nil {
		return 0
	}

	return n.Token.Pos()
}

// BlockOpt represents data reduced by productions:
//
//	BlockOpt:
//	        /* empty */  // Case 0
//	|       Block        // Case 1
type BlockOpt struct {
	Block *Block
}

func (n *BlockOpt) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *BlockOpt) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *BlockOpt) Pos() token.Pos {
	if n == nil {
		return 0
	}

	return n.Block.Pos()
}

// Body represents data reduced by production:
//
//	Body:
//	        BODY StatementList '}'  // Case 0
type Body struct {
	scope         *Scope
	StatementList *StatementList
	Token         xc.Token
	Token2        xc.Token
}

func (n *Body) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *Body) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *Body) Pos() token.Pos {
	if n == nil {
		return 0
	}

	return n.Token.Pos()
}

// Call represents data reduced by productions:
//
//	Call:
//	        '(' ')'                              // Case 0
//	|       '(' ArgumentList CommaOpt ')'        // Case 1
//	|       '(' ArgumentList "..." CommaOpt ')'  // Case 2
type Call struct {
	ArgumentList *ArgumentList
	Case         int
	CommaOpt     *CommaOpt
	Token        xc.Token
	Token2       xc.Token
	Token3       xc.Token
}

func (n *Call) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *Call) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *Call) Pos() token.Pos {
	if n == nil {
		return 0
	}

	return n.Token.Pos()
}

// ChanType represents data reduced by productions:
//
//	ChanType:
//	        "chan" Type    // Case 0
//	|       "chan<-" Type  // Case 1
//	|       "<-chan" Type  // Case 2
type ChanType struct {
	Case  int
	Token xc.Token
	Type  *Type
}

func (n *ChanType) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *ChanType) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *ChanType) Pos() token.Pos {
	if n == nil {
		return 0
	}

	return n.Token.Pos()
}

// CommaOpt represents data reduced by productions:
//
//	CommaOpt:
//	        /* empty */  // Case 0
//	|       ','          // Case 1
type CommaOpt struct {
	Token xc.Token
}

func (n *CommaOpt) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *CommaOpt) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *CommaOpt) Pos() token.Pos {
	if n == nil {
		return 0
	}

	return n.Token.Pos()
}

// CompLitItem represents data reduced by productions:
//
//	CompLitItem:
//	        Expression                   // Case 0
//	|       CompLitValue                 // Case 1
//	|       Expression ':' Expression    // Case 2
//	|       Expression ':' CompLitValue  // Case 3
type CompLitItem struct {
	Case         int
	CompLitValue *CompLitValue
	Expression   *Expression
	Expression2  *Expression
	Token        xc.Token
}

func (n *CompLitItem) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *CompLitItem) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *CompLitItem) Pos() token.Pos {
	if n == nil {
		return 0
	}

	switch n.Case {
	case 1:
		return n.CompLitValue.Pos()
	case 0, 2, 3:
		return n.Expression.Pos()
	default:
		panic("internal error")
	}
}

// CompLitItemList represents data reduced by productions:
//
//	CompLitItemList:
//	        CompLitItem                      // Case 0
//	|       CompLitItemList ',' CompLitItem  // Case 1
type CompLitItemList struct {
	Case            int
	CompLitItem     *CompLitItem
	CompLitItemList *CompLitItemList
	Token           xc.Token
}

func (n *CompLitItemList) reverse() *CompLitItemList {
	if n == nil {
		return nil
	}

	na := n
	nb := na.CompLitItemList
	for nb != nil {
		nc := nb.CompLitItemList
		nb.CompLitItemList = na
		na = nb
		nb = nc
	}
	n.CompLitItemList = nil
	return na
}

func (n *CompLitItemList) fragment() interface{} { return n.reverse() }

// String implements fmt.Stringer.
func (n *CompLitItemList) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *CompLitItemList) Pos() token.Pos {
	if n == nil {
		return 0
	}

	switch n.Case {
	case 0:
		return n.CompLitItem.Pos()
	case 1:
		return n.CompLitItemList.Pos()
	default:
		panic("internal error")
	}
}

// CompLitType represents data reduced by productions:
//
//	CompLitType:
//	        ArrayType   // Case 0
//	|       MapType     // Case 1
//	|       SliceType   // Case 2
//	|       StructType  // Case 3
type CompLitType struct {
	ArrayType  *ArrayType
	Case       int
	MapType    *MapType
	SliceType  *SliceType
	StructType *StructType
}

func (n *CompLitType) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *CompLitType) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *CompLitType) Pos() token.Pos {
	if n == nil {
		return 0
	}

	switch n.Case {
	case 0:
		return n.ArrayType.Pos()
	case 1:
		return n.MapType.Pos()
	case 2:
		return n.SliceType.Pos()
	case 3:
		return n.StructType.Pos()
	default:
		panic("internal error")
	}
}

// CompLitValue represents data reduced by productions:
//
//	CompLitValue:
//	        '{' '}'                           // Case 0
//	|       '{' CompLitItemList CommaOpt '}'  // Case 1
type CompLitValue struct {
	Case            int
	CommaOpt        *CommaOpt
	CompLitItemList *CompLitItemList
	Token           xc.Token
	Token2          xc.Token
}

func (n *CompLitValue) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *CompLitValue) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *CompLitValue) Pos() token.Pos {
	if n == nil {
		return 0
	}

	return n.Token.Pos()
}

// ConstDecl represents data reduced by productions:
//
//	ConstDecl:
//	        "const" '(' ')'                             // Case 0
//	|       "const" '(' ConstSpecList SemicolonOpt ')'  // Case 1
//	|       "const" ConstSpec                           // Case 2
type ConstDecl struct {
	Case          int
	ConstSpec     *ConstSpec
	ConstSpecList *ConstSpecList
	SemicolonOpt  *SemicolonOpt
	Token         xc.Token
	Token2        xc.Token
	Token3        xc.Token
}

func (n *ConstDecl) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *ConstDecl) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *ConstDecl) Pos() token.Pos {
	if n == nil {
		return 0
	}

	return n.Token.Pos()
}

// ConstSpec represents data reduced by productions:
//
//	ConstSpec:
//	        IdentifierList                          // Case 0
//	|       IdentifierList '=' ExpressionList       // Case 1
//	|       IdentifierList Type '=' ExpressionList  // Case 2
type ConstSpec struct {
	Predeclared int
	ref
	Case           int
	ExpressionList *ExpressionList
	IdentifierList *IdentifierList
	Token          xc.Token
	Type           *Type
}

func (n *ConstSpec) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *ConstSpec) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *ConstSpec) Pos() token.Pos {
	if n == nil {
		return 0
	}

	return n.IdentifierList.Pos()
}

// ConstSpecList represents data reduced by productions:
//
//	ConstSpecList:
//	        ConstSpec                    // Case 0
//	|       ConstSpecList ';' ConstSpec  // Case 1
type ConstSpecList struct {
	Case          int
	ConstSpec     *ConstSpec
	ConstSpecList *ConstSpecList
	Token         xc.Token
}

func (n *ConstSpecList) reverse() *ConstSpecList {
	if n == nil {
		return nil
	}

	na := n
	nb := na.ConstSpecList
	for nb != nil {
		nc := nb.ConstSpecList
		nb.ConstSpecList = na
		na = nb
		nb = nc
	}
	n.ConstSpecList = nil
	return na
}

func (n *ConstSpecList) fragment() interface{} { return n.reverse() }

// String implements fmt.Stringer.
func (n *ConstSpecList) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *ConstSpecList) Pos() token.Pos {
	if n == nil {
		return 0
	}

	switch n.Case {
	case 0:
		return n.ConstSpec.Pos()
	case 1:
		return n.ConstSpecList.Pos()
	default:
		panic("internal error")
	}
}

// Elif represents data reduced by production:
//
//	Elif:
//	        "else" "if" IfHeader Body  // Case 0
type Elif struct {
	Body     *Body
	IfHeader *IfHeader
	Token    xc.Token
	Token2   xc.Token
}

func (n *Elif) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *Elif) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *Elif) Pos() token.Pos {
	if n == nil {
		return 0
	}

	return n.Token.Pos()
}

// ElifList represents data reduced by productions:
//
//	ElifList:
//	        /* empty */    // Case 0
//	|       ElifList Elif  // Case 1
type ElifList struct {
	Elif     *Elif
	ElifList *ElifList
}

func (n *ElifList) reverse() *ElifList {
	if n == nil {
		return nil
	}

	na := n
	nb := na.ElifList
	for nb != nil {
		nc := nb.ElifList
		nb.ElifList = na
		na = nb
		nb = nc
	}
	n.ElifList = nil
	return na
}

func (n *ElifList) fragment() interface{} { return n.reverse() }

// String implements fmt.Stringer.
func (n *ElifList) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *ElifList) Pos() token.Pos {
	if n == nil {
		return 0
	}

	if p := n.ElifList.Pos(); p != 0 {
		return p
	}

	return n.Elif.Pos()
}

// Else represents data reduced by productions:
//
//	Else:
//	        /* empty */   // Case 0
//	|       "else" Block  // Case 1
type Else struct {
	Block *Block
	Token xc.Token
}

func (n *Else) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *Else) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *Else) Pos() token.Pos {
	if n == nil {
		return 0
	}

	return n.Token.Pos()
}

// ExpressionCase represents case numbers of production Expression
type ExpressionCase int

// Values of type ExpressionCase
const (
	ExpressionUnary ExpressionCase = iota
	ExpressionMod
	ExpressionAnd
	ExpressionMul
	ExpressionAdd
	ExpressionSub
	ExpressionDiv
	ExpressionLt
	ExpressionGt
	ExpressionXor
	ExpressionOr
	_
	ExpressionAndNot
	ExpressionEq
	ExpressionGe
	ExpressionLe
	ExpressionLsh
	ExpressionNe
	ExpressionLOr
	ExpressionRsh
	ExpressionRx
)

// String implements fmt.Stringer
func (n ExpressionCase) String() string {
	switch n {
	case ExpressionUnary:
		return "ExpressionUnary"
	case ExpressionMod:
		return "ExpressionMod"
	case ExpressionAnd:
		return "ExpressionAnd"
	case ExpressionMul:
		return "ExpressionMul"
	case ExpressionAdd:
		return "ExpressionAdd"
	case ExpressionSub:
		return "ExpressionSub"
	case ExpressionDiv:
		return "ExpressionDiv"
	case ExpressionLt:
		return "ExpressionLt"
	case ExpressionGt:
		return "ExpressionGt"
	case ExpressionXor:
		return "ExpressionXor"
	case ExpressionOr:
		return "ExpressionOr"
	case ExpressionAndNot:
		return "ExpressionAndNot"
	case ExpressionEq:
		return "ExpressionEq"
	case ExpressionGe:
		return "ExpressionGe"
	case ExpressionLe:
		return "ExpressionLe"
	case ExpressionLsh:
		return "ExpressionLsh"
	case ExpressionNe:
		return "ExpressionNe"
	case ExpressionLOr:
		return "ExpressionLOr"
	case ExpressionRsh:
		return "ExpressionRsh"
	case ExpressionRx:
		return "ExpressionRx"
	default:
		return fmt.Sprintf("ExpressionCase(%v)", n)
	}
}

// Expression represents data reduced by productions:
//
//	Expression:
//	        UnaryExpression             // Case ExpressionUnary
//	|       Expression '%' Expression   // Case ExpressionMod
//	|       Expression '&' Expression   // Case ExpressionAnd
//	|       Expression '*' Expression   // Case ExpressionMul
//	|       Expression '+' Expression   // Case ExpressionAdd
//	|       Expression '-' Expression   // Case ExpressionSub
//	|       Expression '/' Expression   // Case ExpressionDiv
//	|       Expression '<' Expression   // Case ExpressionLt
//	|       Expression '>' Expression   // Case ExpressionGt
//	|       Expression '^' Expression   // Case ExpressionXor
//	|       Expression '|' Expression   // Case ExpressionOr
//	|       Expression "&&" Expression  // Case 11
//	|       Expression "&^" Expression  // Case ExpressionAndNot
//	|       Expression "==" Expression  // Case ExpressionEq
//	|       Expression ">=" Expression  // Case ExpressionGe
//	|       Expression "<=" Expression  // Case ExpressionLe
//	|       Expression "<<" Expression  // Case ExpressionLsh
//	|       Expression "!=" Expression  // Case ExpressionNe
//	|       Expression "||" Expression  // Case ExpressionLOr
//	|       Expression ">>" Expression  // Case ExpressionRsh
//	|       Expression "<-" Expression  // Case ExpressionRx
type Expression struct {
	Case            ExpressionCase
	Expression      *Expression
	Expression2     *Expression
	Token           xc.Token
	UnaryExpression *UnaryExpression
}

func (n *Expression) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *Expression) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *Expression) Pos() token.Pos {
	if n == nil {
		return 0
	}

	switch n.Case {
	case 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20:
		return n.Expression.Pos()
	case 0:
		return n.UnaryExpression.Pos()
	default:
		panic("internal error")
	}
}

// ExpressionList represents data reduced by productions:
//
//	ExpressionList:
//	        Expression                     // Case 0
//	|       ExpressionList ',' Expression  // Case 1
type ExpressionList struct {
	Case           int
	Expression     *Expression
	ExpressionList *ExpressionList
	Token          xc.Token
}

func (n *ExpressionList) reverse() *ExpressionList {
	if n == nil {
		return nil
	}

	na := n
	nb := na.ExpressionList
	for nb != nil {
		nc := nb.ExpressionList
		nb.ExpressionList = na
		na = nb
		nb = nc
	}
	n.ExpressionList = nil
	return na
}

func (n *ExpressionList) fragment() interface{} { return n.reverse() }

// String implements fmt.Stringer.
func (n *ExpressionList) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *ExpressionList) Pos() token.Pos {
	if n == nil {
		return 0
	}

	switch n.Case {
	case 0:
		return n.Expression.Pos()
	case 1:
		return n.ExpressionList.Pos()
	default:
		panic("internal error")
	}
}

// ExpressionListOpt represents data reduced by productions:
//
//	ExpressionListOpt:
//	        /* empty */     // Case 0
//	|       ExpressionList  // Case 1
type ExpressionListOpt struct {
	ExpressionList *ExpressionList
}

func (n *ExpressionListOpt) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *ExpressionListOpt) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *ExpressionListOpt) Pos() token.Pos {
	if n == nil {
		return 0
	}

	return n.ExpressionList.Pos()
}

// ExpressionOpt represents data reduced by productions:
//
//	ExpressionOpt:
//	        /* empty */  // Case 0
//	|       Expression   // Case 1
type ExpressionOpt struct {
	Expression *Expression
}

func (n *ExpressionOpt) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *ExpressionOpt) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *ExpressionOpt) Pos() token.Pos {
	if n == nil {
		return 0
	}

	return n.Expression.Pos()
}

// File represents data reduced by production:
//
//	File:
//	        Prologue TopLevelDeclList  // Case 0
type File struct {
	Prologue         *Prologue
	TopLevelDeclList *TopLevelDeclList
}

func (n *File) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *File) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *File) Pos() token.Pos {
	if n == nil {
		return 0
	}

	return n.Prologue.Pos()
}

// ForHeader represents data reduced by productions:
//
//	ForHeader:
//	        Range                                                             // Case 0
//	|       SimpleStatementOpt ';' SimpleStatementOpt ';' SimpleStatementOpt  // Case 1
//	|       SimpleStatementOpt                                                // Case 2
type ForHeader struct {
	Case                int
	Range               *Range
	SimpleStatementOpt  *SimpleStatementOpt
	SimpleStatementOpt2 *SimpleStatementOpt
	SimpleStatementOpt3 *SimpleStatementOpt
	Token               xc.Token
	Token2              xc.Token
}

func (n *ForHeader) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *ForHeader) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *ForHeader) Pos() token.Pos {
	if n == nil {
		return 0
	}

	switch n.Case {
	case 0:
		return n.Range.Pos()
	case 2:
		return n.SimpleStatementOpt.Pos()
	case 1:
		if p := n.SimpleStatementOpt.Pos(); p != 0 {
			return p
		}

		return n.Token.Pos()
	default:
		panic("internal error")
	}
}

// ForStatement represents data reduced by production:
//
//	ForStatement:
//	        "for" ForHeader Body  // Case 0
type ForStatement struct {
	Body      *Body
	ForHeader *ForHeader
	Token     xc.Token
}

func (n *ForStatement) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *ForStatement) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *ForStatement) Pos() token.Pos {
	if n == nil {
		return 0
	}

	return n.Token.Pos()
}

// FuncDecl represents data reduced by production:
//
//	FuncDecl:
//	        FuncOrMethod BlockOpt  // Case 0
type FuncDecl struct {
	BlockOpt     *BlockOpt
	FuncOrMethod *FuncOrMethod
}

func (n *FuncDecl) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *FuncDecl) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *FuncDecl) Pos() token.Pos {
	if n == nil {
		return 0
	}

	return n.FuncOrMethod.Pos()
}

// FuncOrMethod represents data reduced by production:
//
//	FuncOrMethod:
//	        "func" ReceiverOpt IDENTIFIER Signature  // Case 0
type FuncOrMethod struct {
	Block *Block
	ref
	ReceiverOpt *ReceiverOpt
	Signature   *Signature
	Token       xc.Token
	Token2      xc.Token
}

func (n *FuncOrMethod) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *FuncOrMethod) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *FuncOrMethod) Pos() token.Pos {
	if n == nil {
		return 0
	}

	return n.Token.Pos()
}

// FuncType represents data reduced by production:
//
//	FuncType:
//	        "func" Signature  // Case 0
type FuncType struct {
	Signature *Signature
	Token     xc.Token
}

func (n *FuncType) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *FuncType) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *FuncType) Pos() token.Pos {
	if n == nil {
		return 0
	}

	return n.Token.Pos()
}

// IdentifierList represents data reduced by productions:
//
//	IdentifierList:
//	        IDENTIFIER                     // Case 0
//	|       IdentifierList ',' IDENTIFIER  // Case 1
type IdentifierList struct {
	Case           int
	IdentifierList *IdentifierList
	Token          xc.Token
	Token2         xc.Token
}

func (n *IdentifierList) reverse() *IdentifierList {
	if n == nil {
		return nil
	}

	na := n
	nb := na.IdentifierList
	for nb != nil {
		nc := nb.IdentifierList
		nb.IdentifierList = na
		na = nb
		nb = nc
	}
	n.IdentifierList = nil
	return na
}

func (n *IdentifierList) fragment() interface{} { return n.reverse() }

// String implements fmt.Stringer.
func (n *IdentifierList) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *IdentifierList) Pos() token.Pos {
	if n == nil {
		return 0
	}

	switch n.Case {
	case 1:
		return n.IdentifierList.Pos()
	case 0:
		return n.Token.Pos()
	default:
		panic("internal error")
	}
}

// IdentifierOpt represents data reduced by productions:
//
//	IdentifierOpt:
//	        /* empty */  // Case 0
//	|       IDENTIFIER   // Case 1
type IdentifierOpt struct {
	Token xc.Token
}

func (n *IdentifierOpt) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *IdentifierOpt) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *IdentifierOpt) Pos() token.Pos {
	if n == nil {
		return 0
	}

	return n.Token.Pos()
}

// IfHeader represents data reduced by productions:
//
//	IfHeader:
//	        SimpleStatementOpt                         // Case 0
//	|       SimpleStatementOpt ';' SimpleStatementOpt  // Case 1
type IfHeader struct {
	Case                int
	SimpleStatementOpt  *SimpleStatementOpt
	SimpleStatementOpt2 *SimpleStatementOpt
	Token               xc.Token
}

func (n *IfHeader) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *IfHeader) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *IfHeader) Pos() token.Pos {
	if n == nil {
		return 0
	}

	switch n.Case {
	case 0:
		return n.SimpleStatementOpt.Pos()
	case 1:
		if p := n.SimpleStatementOpt.Pos(); p != 0 {
			return p
		}

		return n.Token.Pos()
	default:
		panic("internal error")
	}
}

// IfStatement represents data reduced by production:
//
//	IfStatement:
//	        "if" IfHeader Body ElifList Else  // Case 0
type IfStatement struct {
	Body     *Body
	ElifList *ElifList
	Else     *Else
	IfHeader *IfHeader
	Token    xc.Token
}

func (n *IfStatement) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *IfStatement) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *IfStatement) Pos() token.Pos {
	if n == nil {
		return 0
	}

	return n.Token.Pos()
}

// ImportDecl represents data reduced by productions:
//
//	ImportDecl:
//	        "import" '(' ')'                              // Case 0
//	|       "import" '(' ImportSpecList SemicolonOpt ')'  // Case 1
//	|       "import" ImportSpec                           // Case 2
type ImportDecl struct {
	Case           int
	ImportSpec     *ImportSpec
	ImportSpecList *ImportSpecList
	SemicolonOpt   *SemicolonOpt
	Token          xc.Token
	Token2         xc.Token
	Token3         xc.Token
}

func (n *ImportDecl) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *ImportDecl) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *ImportDecl) Pos() token.Pos {
	if n == nil {
		return 0
	}

	return n.Token.Pos()
}

// ImportList represents data reduced by productions:
//
//	ImportList:
//	        /* empty */                // Case 0
//	|       ImportList ImportDecl ';'  // Case 1
type ImportList struct {
	ImportDecl *ImportDecl
	ImportList *ImportList
	Token      xc.Token
}

func (n *ImportList) reverse() *ImportList {
	if n == nil {
		return nil
	}

	na := n
	nb := na.ImportList
	for nb != nil {
		nc := nb.ImportList
		nb.ImportList = na
		na = nb
		nb = nc
	}
	n.ImportList = nil
	return na
}

func (n *ImportList) fragment() interface{} { return n.reverse() }

// String implements fmt.Stringer.
func (n *ImportList) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *ImportList) Pos() token.Pos {
	if n == nil {
		return 0
	}

	if p := n.ImportList.Pos(); p != 0 {
		return p
	}

	return n.ImportDecl.Pos()
}

// ImportPath represents data reduced by production:
//
//	ImportPath:
//	        BasicLiteral  // Case 0
type ImportPath struct {
	once         *xc.Once
	BasicLiteral *BasicLiteral
}

func (n *ImportPath) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *ImportPath) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *ImportPath) Pos() token.Pos {
	if n == nil {
		return 0
	}

	return n.BasicLiteral.Pos()
}

// ImportSpec represents data reduced by productions:
//
//	ImportSpec:
//	        '.' ImportPath            // Case 0
//	|       IdentifierOpt ImportPath  // Case 1
type ImportSpec struct {
	Case          int
	IdentifierOpt *IdentifierOpt
	ImportPath    *ImportPath
	Token         xc.Token
}

func (n *ImportSpec) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *ImportSpec) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *ImportSpec) Pos() token.Pos {
	if n == nil {
		return 0
	}

	switch n.Case {
	case 1:
		if p := n.IdentifierOpt.Pos(); p != 0 {
			return p
		}

		return n.ImportPath.Pos()
	case 0:
		return n.Token.Pos()
	default:
		panic("internal error")
	}
}

// ImportSpecList represents data reduced by productions:
//
//	ImportSpecList:
//	        ImportSpec                     // Case 0
//	|       ImportSpecList ';' ImportSpec  // Case 1
type ImportSpecList struct {
	Case           int
	ImportSpec     *ImportSpec
	ImportSpecList *ImportSpecList
	Token          xc.Token
}

func (n *ImportSpecList) reverse() *ImportSpecList {
	if n == nil {
		return nil
	}

	na := n
	nb := na.ImportSpecList
	for nb != nil {
		nc := nb.ImportSpecList
		nb.ImportSpecList = na
		na = nb
		nb = nc
	}
	n.ImportSpecList = nil
	return na
}

func (n *ImportSpecList) fragment() interface{} { return n.reverse() }

// String implements fmt.Stringer.
func (n *ImportSpecList) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *ImportSpecList) Pos() token.Pos {
	if n == nil {
		return 0
	}

	switch n.Case {
	case 0:
		return n.ImportSpec.Pos()
	case 1:
		return n.ImportSpecList.Pos()
	default:
		panic("internal error")
	}
}

// InterfaceMethodDecl represents data reduced by productions:
//
//	InterfaceMethodDecl:
//	        IDENTIFIER Signature  // Case 0
//	|       QualifiedIdent        // Case 1
type InterfaceMethodDecl struct {
	Case           int
	QualifiedIdent *QualifiedIdent
	Signature      *Signature
	Token          xc.Token
}

func (n *InterfaceMethodDecl) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *InterfaceMethodDecl) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *InterfaceMethodDecl) Pos() token.Pos {
	if n == nil {
		return 0
	}

	switch n.Case {
	case 1:
		return n.QualifiedIdent.Pos()
	case 0:
		return n.Token.Pos()
	default:
		panic("internal error")
	}
}

// InterfaceMethodDeclList represents data reduced by productions:
//
//	InterfaceMethodDeclList:
//	        InterfaceMethodDecl                              // Case 0
//	|       InterfaceMethodDeclList ';' InterfaceMethodDecl  // Case 1
type InterfaceMethodDeclList struct {
	Case                    int
	InterfaceMethodDecl     *InterfaceMethodDecl
	InterfaceMethodDeclList *InterfaceMethodDeclList
	Token                   xc.Token
}

func (n *InterfaceMethodDeclList) reverse() *InterfaceMethodDeclList {
	if n == nil {
		return nil
	}

	na := n
	nb := na.InterfaceMethodDeclList
	for nb != nil {
		nc := nb.InterfaceMethodDeclList
		nb.InterfaceMethodDeclList = na
		na = nb
		nb = nc
	}
	n.InterfaceMethodDeclList = nil
	return na
}

func (n *InterfaceMethodDeclList) fragment() interface{} { return n.reverse() }

// String implements fmt.Stringer.
func (n *InterfaceMethodDeclList) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *InterfaceMethodDeclList) Pos() token.Pos {
	if n == nil {
		return 0
	}

	switch n.Case {
	case 0:
		return n.InterfaceMethodDecl.Pos()
	case 1:
		return n.InterfaceMethodDeclList.Pos()
	default:
		panic("internal error")
	}
}

// InterfaceType represents data reduced by productions:
//
//	InterfaceType:
//	        "interface" LBrace '}'                                       // Case 0
//	|       "interface" LBrace InterfaceMethodDeclList SemicolonOpt '}'  // Case 1
type InterfaceType struct {
	Case                    int
	InterfaceMethodDeclList *InterfaceMethodDeclList
	LBrace                  *LBrace
	SemicolonOpt            *SemicolonOpt
	Token                   xc.Token
	Token2                  xc.Token
}

func (n *InterfaceType) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *InterfaceType) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *InterfaceType) Pos() token.Pos {
	if n == nil {
		return 0
	}

	return n.Token.Pos()
}

// LBrace represents data reduced by productions:
//
//	LBrace:
//	        BODY  // Case 0
//	|       '{'   // Case 1
type LBrace struct {
	Case  int
	Token xc.Token
}

func (n *LBrace) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *LBrace) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *LBrace) Pos() token.Pos {
	if n == nil {
		return 0
	}

	return n.Token.Pos()
}

// LBraceCompLitItem represents data reduced by productions:
//
//	LBraceCompLitItem:
//	        Expression                         // Case 0
//	|       Expression ':' Expression          // Case 1
//	|       Expression ':' LBraceCompLitValue  // Case 2
//	|       LBraceCompLitValue                 // Case 3
type LBraceCompLitItem struct {
	Case               int
	Expression         *Expression
	Expression2        *Expression
	LBraceCompLitValue *LBraceCompLitValue
	Token              xc.Token
}

func (n *LBraceCompLitItem) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *LBraceCompLitItem) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *LBraceCompLitItem) Pos() token.Pos {
	if n == nil {
		return 0
	}

	switch n.Case {
	case 0, 1, 2:
		return n.Expression.Pos()
	case 3:
		return n.LBraceCompLitValue.Pos()
	default:
		panic("internal error")
	}
}

// LBraceCompLitItemList represents data reduced by productions:
//
//	LBraceCompLitItemList:
//	        LBraceCompLitItem                            // Case 0
//	|       LBraceCompLitItemList ',' LBraceCompLitItem  // Case 1
type LBraceCompLitItemList struct {
	Case                  int
	LBraceCompLitItem     *LBraceCompLitItem
	LBraceCompLitItemList *LBraceCompLitItemList
	Token                 xc.Token
}

func (n *LBraceCompLitItemList) reverse() *LBraceCompLitItemList {
	if n == nil {
		return nil
	}

	na := n
	nb := na.LBraceCompLitItemList
	for nb != nil {
		nc := nb.LBraceCompLitItemList
		nb.LBraceCompLitItemList = na
		na = nb
		nb = nc
	}
	n.LBraceCompLitItemList = nil
	return na
}

func (n *LBraceCompLitItemList) fragment() interface{} { return n.reverse() }

// String implements fmt.Stringer.
func (n *LBraceCompLitItemList) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *LBraceCompLitItemList) Pos() token.Pos {
	if n == nil {
		return 0
	}

	switch n.Case {
	case 0:
		return n.LBraceCompLitItem.Pos()
	case 1:
		return n.LBraceCompLitItemList.Pos()
	default:
		panic("internal error")
	}
}

// LBraceCompLitValue represents data reduced by productions:
//
//	LBraceCompLitValue:
//	        LBrace '}'                                 // Case 0
//	|       LBrace LBraceCompLitItemList CommaOpt '}'  // Case 1
type LBraceCompLitValue struct {
	Case                  int
	CommaOpt              *CommaOpt
	LBrace                *LBrace
	LBraceCompLitItemList *LBraceCompLitItemList
	Token                 xc.Token
}

func (n *LBraceCompLitValue) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *LBraceCompLitValue) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *LBraceCompLitValue) Pos() token.Pos {
	if n == nil {
		return 0
	}

	return n.LBrace.Pos()
}

// MapType represents data reduced by production:
//
//	MapType:
//	        "map" '[' Type ']' Type  // Case 0
type MapType struct {
	Token  xc.Token
	Token2 xc.Token
	Token3 xc.Token
	Type   *Type
	Type2  *Type
}

func (n *MapType) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *MapType) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *MapType) Pos() token.Pos {
	if n == nil {
		return 0
	}

	return n.Token.Pos()
}

// Operand represents data reduced by productions:
//
//	Operand:
//	        '(' Expression ')'                 // Case 0
//	|       '(' TypeLiteral ')'                // Case 1
//	|       BasicLiteral                       // Case 2
//	|       FuncType LBrace StatementList '}'  // Case 3
//	|       FuncType error                     // Case 4
//	|       IDENTIFIER                         // Case 5
type Operand struct {
	BasicLiteral  *BasicLiteral
	Case          int
	Expression    *Expression
	FuncType      *FuncType
	LBrace        *LBrace
	StatementList *StatementList
	Token         xc.Token
	Token2        xc.Token
	TypeLiteral   *TypeLiteral
}

func (n *Operand) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *Operand) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *Operand) Pos() token.Pos {
	if n == nil {
		return 0
	}

	switch n.Case {
	case 2:
		return n.BasicLiteral.Pos()
	case 3, 4:
		return n.FuncType.Pos()
	case 0, 1, 5:
		return n.Token.Pos()
	default:
		panic("internal error")
	}
}

// ParameterDecl represents data reduced by productions:
//
//	ParameterDecl:
//	        "..." Type             // Case 0
//	|       IDENTIFIER "..." Type  // Case 1
//	|       IDENTIFIER Type        // Case 2
//	|       Type                   // Case 3
type ParameterDecl struct {
	ref
	Case   int
	Token  xc.Token
	Token2 xc.Token
	Type   *Type
}

func (n *ParameterDecl) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *ParameterDecl) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *ParameterDecl) Pos() token.Pos {
	if n == nil {
		return 0
	}

	switch n.Case {
	case 0, 1, 2:
		return n.Token.Pos()
	case 3:
		return n.Type.Pos()
	default:
		panic("internal error")
	}
}

// ParameterDeclList represents data reduced by productions:
//
//	ParameterDeclList:
//	        ParameterDecl                        // Case 0
//	|       ParameterDeclList ',' ParameterDecl  // Case 1
type ParameterDeclList struct {
	Case              int
	ParameterDecl     *ParameterDecl
	ParameterDeclList *ParameterDeclList
	Token             xc.Token
}

func (n *ParameterDeclList) reverse() *ParameterDeclList {
	if n == nil {
		return nil
	}

	na := n
	nb := na.ParameterDeclList
	for nb != nil {
		nc := nb.ParameterDeclList
		nb.ParameterDeclList = na
		na = nb
		nb = nc
	}
	n.ParameterDeclList = nil
	return na
}

func (n *ParameterDeclList) fragment() interface{} { return n.reverse() }

// String implements fmt.Stringer.
func (n *ParameterDeclList) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *ParameterDeclList) Pos() token.Pos {
	if n == nil {
		return 0
	}

	switch n.Case {
	case 0:
		return n.ParameterDecl.Pos()
	case 1:
		return n.ParameterDeclList.Pos()
	default:
		panic("internal error")
	}
}

// Parameters represents data reduced by productions:
//
//	Parameters:
//	        '(' ')'                             // Case 0
//	|       '(' ParameterDeclList CommaOpt ')'  // Case 1
type Parameters struct {
	Case              int
	CommaOpt          *CommaOpt
	ParameterDeclList *ParameterDeclList
	Token             xc.Token
	Token2            xc.Token
}

func (n *Parameters) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *Parameters) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *Parameters) Pos() token.Pos {
	if n == nil {
		return 0
	}

	return n.Token.Pos()
}

// PrimaryExpression represents data reduced by productions:
//
//	PrimaryExpression:
//	        Operand                                                                      // Case 0
//	|       CompLitType LBraceCompLitValue                                               // Case 1
//	|       PrimaryExpression '.' '(' "type" ')'                                         // Case 2
//	|       PrimaryExpression '.' '(' Type ')'                                           // Case 3
//	|       PrimaryExpression '.' IDENTIFIER                                             // Case 4
//	|       PrimaryExpression '[' Expression ']'                                         // Case 5
//	|       PrimaryExpression '[' ExpressionOpt ':' ExpressionOpt ':' ExpressionOpt ']'  // Case 6
//	|       PrimaryExpression '[' ExpressionOpt ':' ExpressionOpt ']'                    // Case 7
//	|       PrimaryExpression Call                                                       // Case 8
//	|       PrimaryExpression CompLitValue                                               // Case 9
//	|       TypeLiteral '(' Expression CommaOpt ')'                                      // Case 10
type PrimaryExpression struct {
	Call               *Call
	Case               int
	CommaOpt           *CommaOpt
	CompLitType        *CompLitType
	CompLitValue       *CompLitValue
	Expression         *Expression
	ExpressionOpt      *ExpressionOpt
	ExpressionOpt2     *ExpressionOpt
	ExpressionOpt3     *ExpressionOpt
	LBraceCompLitValue *LBraceCompLitValue
	Operand            *Operand
	PrimaryExpression  *PrimaryExpression
	Token              xc.Token
	Token2             xc.Token
	Token3             xc.Token
	Token4             xc.Token
	Type               *Type
	TypeLiteral        *TypeLiteral
}

func (n *PrimaryExpression) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *PrimaryExpression) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *PrimaryExpression) Pos() token.Pos {
	if n == nil {
		return 0
	}

	switch n.Case {
	case 1:
		return n.CompLitType.Pos()
	case 0:
		return n.Operand.Pos()
	case 2, 3, 4, 5, 6, 7, 8, 9:
		return n.PrimaryExpression.Pos()
	case 10:
		return n.TypeLiteral.Pos()
	default:
		panic("internal error")
	}
}

// Prologue represents data reduced by productions:
//
//	Prologue:
//	        "package" IDENTIFIER ';' ImportList  // Case 0
//	|       error                                // Case 1
type Prologue struct {
	Case       int
	ImportList *ImportList
	Token      xc.Token
	Token2     xc.Token
	Token3     xc.Token
}

func (n *Prologue) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *Prologue) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *Prologue) Pos() token.Pos {
	if n == nil {
		return 0
	}

	return n.Token.Pos()
}

// QualifiedIdent represents data reduced by productions:
//
//	QualifiedIdent:
//	        IDENTIFIER                 // Case 0
//	|       IDENTIFIER '.' IDENTIFIER  // Case 1
type QualifiedIdent struct {
	Case   int
	Token  xc.Token
	Token2 xc.Token
	Token3 xc.Token
}

func (n *QualifiedIdent) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *QualifiedIdent) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *QualifiedIdent) Pos() token.Pos {
	if n == nil {
		return 0
	}

	return n.Token.Pos()
}

// Range represents data reduced by productions:
//
//	Range:
//	        ExpressionList '=' "range" Expression   // Case 0
//	|       ExpressionList ":=" "range" Expression  // Case 1
//	|       "range" Expression                      // Case 2
type Range struct {
	Case           int
	Expression     *Expression
	ExpressionList *ExpressionList
	Token          xc.Token
	Token2         xc.Token
}

func (n *Range) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *Range) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *Range) Pos() token.Pos {
	if n == nil {
		return 0
	}

	switch n.Case {
	case 0, 1:
		return n.ExpressionList.Pos()
	case 2:
		return n.Token.Pos()
	default:
		panic("internal error")
	}
}

// ReceiverOpt represents data reduced by productions:
//
//	ReceiverOpt:
//	        /* empty */  // Case 0
//	|       Parameters   // Case 1
type ReceiverOpt struct {
	Parameters *Parameters
}

func (n *ReceiverOpt) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *ReceiverOpt) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *ReceiverOpt) Pos() token.Pos {
	if n == nil {
		return 0
	}

	return n.Parameters.Pos()
}

// ResultOpt represents data reduced by productions:
//
//	ResultOpt:
//	        /* empty */  // Case 0
//	|       Parameters   // Case 1
//	|       Type         // Case 2
type ResultOpt struct {
	Case       int
	Parameters *Parameters
	Type       *Type
}

func (n *ResultOpt) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *ResultOpt) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *ResultOpt) Pos() token.Pos {
	if n == nil {
		return 0
	}

	switch n.Case {
	case 0:
		return 0
	case 1:
		return n.Parameters.Pos()
	case 2:
		return n.Type.Pos()
	default:
		panic("internal error")
	}
}

// SelectStatement represents data reduced by production:
//
//	SelectStatement:
//	        "select" SwitchBody  // Case 0
type SelectStatement struct {
	SwitchBody *SwitchBody
	Token      xc.Token
}

func (n *SelectStatement) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *SelectStatement) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *SelectStatement) Pos() token.Pos {
	if n == nil {
		return 0
	}

	return n.Token.Pos()
}

// SemicolonOpt represents data reduced by productions:
//
//	SemicolonOpt:
//	        /* empty */  // Case 0
//	|       ';'          // Case 1
type SemicolonOpt struct {
	Token xc.Token
}

func (n *SemicolonOpt) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *SemicolonOpt) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *SemicolonOpt) Pos() token.Pos {
	if n == nil {
		return 0
	}

	return n.Token.Pos()
}

// Signature represents data reduced by production:
//
//	Signature:
//	        Parameters ResultOpt  // Case 0
type Signature struct {
	Parameters *Parameters
	ResultOpt  *ResultOpt
}

func (n *Signature) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *Signature) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *Signature) Pos() token.Pos {
	if n == nil {
		return 0
	}

	return n.Parameters.Pos()
}

// SimpleStatement represents data reduced by productions:
//
//	SimpleStatement:
//	        Assignment                          // Case 0
//	|       Expression                          // Case 1
//	|       Expression "--"                     // Case 2
//	|       Expression "++"                     // Case 3
//	|       ExpressionList ":=" ExpressionList  // Case 4
type SimpleStatement struct {
	Assignment      *Assignment
	Case            int
	Expression      *Expression
	ExpressionList  *ExpressionList
	ExpressionList2 *ExpressionList
	Token           xc.Token
}

func (n *SimpleStatement) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *SimpleStatement) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *SimpleStatement) Pos() token.Pos {
	if n == nil {
		return 0
	}

	switch n.Case {
	case 0:
		return n.Assignment.Pos()
	case 1, 2, 3:
		return n.Expression.Pos()
	case 4:
		return n.ExpressionList.Pos()
	default:
		panic("internal error")
	}
}

// SimpleStatementOpt represents data reduced by productions:
//
//	SimpleStatementOpt:
//	        /* empty */      // Case 0
//	|       SimpleStatement  // Case 1
type SimpleStatementOpt struct {
	SimpleStatement *SimpleStatement
}

func (n *SimpleStatementOpt) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *SimpleStatementOpt) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *SimpleStatementOpt) Pos() token.Pos {
	if n == nil {
		return 0
	}

	return n.SimpleStatement.Pos()
}

// SliceType represents data reduced by production:
//
//	SliceType:
//	        '[' ']' Type  // Case 0
type SliceType struct {
	Token  xc.Token
	Token2 xc.Token
	Type   *Type
}

func (n *SliceType) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *SliceType) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *SliceType) Pos() token.Pos {
	if n == nil {
		return 0
	}

	return n.Token.Pos()
}

// Statement represents data reduced by productions:
//
//	Statement:
//	        /* empty */       // Case 0
//	|       Block             // Case 1
//	|       ConstDecl         // Case 2
//	|       TypeDecl          // Case 3
//	|       VarDecl           // Case 4
//	|       StatementNonDecl  // Case 5
type Statement struct {
	Block            *Block
	Case             int
	ConstDecl        *ConstDecl
	StatementNonDecl *StatementNonDecl
	TypeDecl         *TypeDecl
	VarDecl          *VarDecl
}

func (n *Statement) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *Statement) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *Statement) Pos() token.Pos {
	if n == nil {
		return 0
	}

	switch n.Case {
	case 0:
		return 0
	case 1:
		return n.Block.Pos()
	case 2:
		return n.ConstDecl.Pos()
	case 5:
		return n.StatementNonDecl.Pos()
	case 3:
		return n.TypeDecl.Pos()
	case 4:
		return n.VarDecl.Pos()
	default:
		panic("internal error")
	}
}

// StatementList represents data reduced by productions:
//
//	StatementList:
//	        Statement                    // Case 0
//	|       StatementList ';' Statement  // Case 1
type StatementList struct {
	Case          int
	Statement     *Statement
	StatementList *StatementList
	Token         xc.Token
}

func (n *StatementList) reverse() *StatementList {
	if n == nil {
		return nil
	}

	na := n
	nb := na.StatementList
	for nb != nil {
		nc := nb.StatementList
		nb.StatementList = na
		na = nb
		nb = nc
	}
	n.StatementList = nil
	return na
}

func (n *StatementList) fragment() interface{} { return n.reverse() }

// String implements fmt.Stringer.
func (n *StatementList) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *StatementList) Pos() token.Pos {
	if n == nil {
		return 0
	}

	switch n.Case {
	case 0:
		return n.Statement.Pos()
	case 1:
		if p := n.StatementList.Pos(); p != 0 {
			return p
		}

		return n.Token.Pos()
	default:
		panic("internal error")
	}
}

// StatementNonDecl represents data reduced by productions:
//
//	StatementNonDecl:
//	        "break" IdentifierOpt       // Case 0
//	|       "continue" IdentifierOpt    // Case 1
//	|       "defer" Expression          // Case 2
//	|       "fallthrough"               // Case 3
//	|       ForStatement                // Case 4
//	|       "go" Expression             // Case 5
//	|       "goto" IDENTIFIER           // Case 6
//	|       IDENTIFIER ':' Statement    // Case 7
//	|       IfStatement                 // Case 8
//	|       "return" ExpressionListOpt  // Case 9
//	|       SelectStatement             // Case 10
//	|       SimpleStatement             // Case 11
//	|       SwitchStatement             // Case 12
//	|       error                       // Case 13
type StatementNonDecl struct {
	Case              int
	Expression        *Expression
	ExpressionListOpt *ExpressionListOpt
	ForStatement      *ForStatement
	IdentifierOpt     *IdentifierOpt
	IfStatement       *IfStatement
	SelectStatement   *SelectStatement
	SimpleStatement   *SimpleStatement
	Statement         *Statement
	SwitchStatement   *SwitchStatement
	Token             xc.Token
	Token2            xc.Token
}

func (n *StatementNonDecl) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *StatementNonDecl) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *StatementNonDecl) Pos() token.Pos {
	if n == nil {
		return 0
	}

	switch n.Case {
	case 4:
		return n.ForStatement.Pos()
	case 8:
		return n.IfStatement.Pos()
	case 10:
		return n.SelectStatement.Pos()
	case 11:
		return n.SimpleStatement.Pos()
	case 12:
		return n.SwitchStatement.Pos()
	case 0, 1, 2, 3, 5, 6, 7, 9, 13:
		return n.Token.Pos()
	default:
		panic("internal error")
	}
}

// StringLitOpt represents data reduced by productions:
//
//	StringLitOpt:
//	        /* empty */  // Case 0
//	|       STRING_LIT   // Case 1
type StringLitOpt struct {
	Token xc.Token
}

func (n *StringLitOpt) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *StringLitOpt) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *StringLitOpt) Pos() token.Pos {
	if n == nil {
		return 0
	}

	return n.Token.Pos()
}

// StructFieldDecl represents data reduced by productions:
//
//	StructFieldDecl:
//	        '*' QualifiedIdent StringLitOpt          // Case 0
//	|       IdentifierList Type StringLitOpt         // Case 1
//	|       QualifiedIdent StringLitOpt              // Case 2
//	|       '(' QualifiedIdent ')' StringLitOpt      // Case 3
//	|       '(' '*' QualifiedIdent ')' StringLitOpt  // Case 4
//	|       '*' '(' QualifiedIdent ')' StringLitOpt  // Case 5
type StructFieldDecl struct {
	Case           int
	IdentifierList *IdentifierList
	QualifiedIdent *QualifiedIdent
	StringLitOpt   *StringLitOpt
	Token          xc.Token
	Token2         xc.Token
	Token3         xc.Token
	Type           *Type
}

func (n *StructFieldDecl) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *StructFieldDecl) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *StructFieldDecl) Pos() token.Pos {
	if n == nil {
		return 0
	}

	switch n.Case {
	case 1:
		return n.IdentifierList.Pos()
	case 2:
		return n.QualifiedIdent.Pos()
	case 0, 3, 4, 5:
		return n.Token.Pos()
	default:
		panic("internal error")
	}
}

// StructFieldDeclList represents data reduced by productions:
//
//	StructFieldDeclList:
//	        StructFieldDecl                          // Case 0
//	|       StructFieldDeclList ';' StructFieldDecl  // Case 1
type StructFieldDeclList struct {
	Case                int
	StructFieldDecl     *StructFieldDecl
	StructFieldDeclList *StructFieldDeclList
	Token               xc.Token
}

func (n *StructFieldDeclList) reverse() *StructFieldDeclList {
	if n == nil {
		return nil
	}

	na := n
	nb := na.StructFieldDeclList
	for nb != nil {
		nc := nb.StructFieldDeclList
		nb.StructFieldDeclList = na
		na = nb
		nb = nc
	}
	n.StructFieldDeclList = nil
	return na
}

func (n *StructFieldDeclList) fragment() interface{} { return n.reverse() }

// String implements fmt.Stringer.
func (n *StructFieldDeclList) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *StructFieldDeclList) Pos() token.Pos {
	if n == nil {
		return 0
	}

	switch n.Case {
	case 0:
		return n.StructFieldDecl.Pos()
	case 1:
		return n.StructFieldDeclList.Pos()
	default:
		panic("internal error")
	}
}

// StructType represents data reduced by productions:
//
//	StructType:
//	        "struct" LBrace '}'                                   // Case 0
//	|       "struct" LBrace StructFieldDeclList SemicolonOpt '}'  // Case 1
type StructType struct {
	Case                int
	LBrace              *LBrace
	SemicolonOpt        *SemicolonOpt
	StructFieldDeclList *StructFieldDeclList
	Token               xc.Token
	Token2              xc.Token
}

func (n *StructType) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *StructType) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *StructType) Pos() token.Pos {
	if n == nil {
		return 0
	}

	return n.Token.Pos()
}

// SwitchBody represents data reduced by productions:
//
//	SwitchBody:
//	        BODY '}'                 // Case 0
//	|       BODY SwitchCaseList '}'  // Case 1
type SwitchBody struct {
	Case           int
	SwitchCaseList *SwitchCaseList
	Token          xc.Token
	Token2         xc.Token
}

func (n *SwitchBody) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *SwitchBody) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *SwitchBody) Pos() token.Pos {
	if n == nil {
		return 0
	}

	return n.Token.Pos()
}

// SwitchCase represents data reduced by productions:
//
//	SwitchCase:
//	        "case" ArgumentList ':'                  // Case 0
//	|       "case" ArgumentList '=' Expression ':'   // Case 1
//	|       "case" ArgumentList ":=" Expression ':'  // Case 2
//	|       "default" ':'                            // Case 3
type SwitchCase struct {
	ArgumentList *ArgumentList
	Case         int
	Expression   *Expression
	Token        xc.Token
	Token2       xc.Token
	Token3       xc.Token
}

func (n *SwitchCase) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *SwitchCase) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *SwitchCase) Pos() token.Pos {
	if n == nil {
		return 0
	}

	return n.Token.Pos()
}

// SwitchCaseBlock represents data reduced by production:
//
//	SwitchCaseBlock:
//	        SwitchCase StatementList  // Case 0
type SwitchCaseBlock struct {
	StatementList *StatementList
	SwitchCase    *SwitchCase
}

func (n *SwitchCaseBlock) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *SwitchCaseBlock) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *SwitchCaseBlock) Pos() token.Pos {
	if n == nil {
		return 0
	}

	return n.SwitchCase.Pos()
}

// SwitchCaseList represents data reduced by productions:
//
//	SwitchCaseList:
//	        SwitchCaseBlock                 // Case 0
//	|       SwitchCaseList SwitchCaseBlock  // Case 1
type SwitchCaseList struct {
	Case            int
	SwitchCaseBlock *SwitchCaseBlock
	SwitchCaseList  *SwitchCaseList
}

func (n *SwitchCaseList) reverse() *SwitchCaseList {
	if n == nil {
		return nil
	}

	na := n
	nb := na.SwitchCaseList
	for nb != nil {
		nc := nb.SwitchCaseList
		nb.SwitchCaseList = na
		na = nb
		nb = nc
	}
	n.SwitchCaseList = nil
	return na
}

func (n *SwitchCaseList) fragment() interface{} { return n.reverse() }

// String implements fmt.Stringer.
func (n *SwitchCaseList) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *SwitchCaseList) Pos() token.Pos {
	if n == nil {
		return 0
	}

	switch n.Case {
	case 0:
		return n.SwitchCaseBlock.Pos()
	case 1:
		return n.SwitchCaseList.Pos()
	default:
		panic("internal error")
	}
}

// SwitchStatement represents data reduced by production:
//
//	SwitchStatement:
//	        "switch" IfHeader SwitchBody  // Case 0
type SwitchStatement struct {
	IfHeader   *IfHeader
	SwitchBody *SwitchBody
	Token      xc.Token
}

func (n *SwitchStatement) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *SwitchStatement) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *SwitchStatement) Pos() token.Pos {
	if n == nil {
		return 0
	}

	return n.Token.Pos()
}

// TopLevelDecl represents data reduced by productions:
//
//	TopLevelDecl:
//	        ConstDecl  // Case 0
//	|       FuncDecl   // Case 1
//	|       TypeDecl   // Case 2
//	|       VarDecl    // Case 3
//	|       error      // Case 4
type TopLevelDecl struct {
	Case      int
	ConstDecl *ConstDecl
	FuncDecl  *FuncDecl
	Token     xc.Token
	TypeDecl  *TypeDecl
	VarDecl   *VarDecl
}

func (n *TopLevelDecl) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *TopLevelDecl) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *TopLevelDecl) Pos() token.Pos {
	if n == nil {
		return 0
	}

	switch n.Case {
	case 0:
		return n.ConstDecl.Pos()
	case 1:
		return n.FuncDecl.Pos()
	case 4:
		return n.Token.Pos()
	case 2:
		return n.TypeDecl.Pos()
	case 3:
		return n.VarDecl.Pos()
	default:
		panic("internal error")
	}
}

// TopLevelDeclList represents data reduced by productions:
//
//	TopLevelDeclList:
//	        /* empty */                        // Case 0
//	|       TopLevelDeclList TopLevelDecl ';'  // Case 1
type TopLevelDeclList struct {
	Token            xc.Token
	TopLevelDecl     *TopLevelDecl
	TopLevelDeclList *TopLevelDeclList
}

func (n *TopLevelDeclList) reverse() *TopLevelDeclList {
	if n == nil {
		return nil
	}

	na := n
	nb := na.TopLevelDeclList
	for nb != nil {
		nc := nb.TopLevelDeclList
		nb.TopLevelDeclList = na
		na = nb
		nb = nc
	}
	n.TopLevelDeclList = nil
	return na
}

func (n *TopLevelDeclList) fragment() interface{} { return n.reverse() }

// String implements fmt.Stringer.
func (n *TopLevelDeclList) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *TopLevelDeclList) Pos() token.Pos {
	if n == nil {
		return 0
	}

	if p := n.TopLevelDeclList.Pos(); p != 0 {
		return p
	}

	return n.TopLevelDecl.Pos()
}

// Type represents data reduced by productions:
//
//	Type:
//	        '(' Type ')'    // Case 0
//	|       '*' Type        // Case 1
//	|       ArrayType       // Case 2
//	|       ChanType        // Case 3
//	|       FuncType        // Case 4
//	|       InterfaceType   // Case 5
//	|       MapType         // Case 6
//	|       QualifiedIdent  // Case 7
//	|       SliceType       // Case 8
//	|       StructType      // Case 9
type Type struct {
	Predeclared    int
	UnderlyingType *Type
	scope          *Scope
	ArrayType      *ArrayType
	Case           int
	ChanType       *ChanType
	FuncType       *FuncType
	InterfaceType  *InterfaceType
	MapType        *MapType
	QualifiedIdent *QualifiedIdent
	SliceType      *SliceType
	StructType     *StructType
	Token          xc.Token
	Token2         xc.Token
	Type           *Type
}

func (n *Type) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *Type) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *Type) Pos() token.Pos {
	if n == nil {
		return 0
	}

	switch n.Case {
	case 2:
		return n.ArrayType.Pos()
	case 3:
		return n.ChanType.Pos()
	case 4:
		return n.FuncType.Pos()
	case 5:
		return n.InterfaceType.Pos()
	case 6:
		return n.MapType.Pos()
	case 7:
		return n.QualifiedIdent.Pos()
	case 8:
		return n.SliceType.Pos()
	case 9:
		return n.StructType.Pos()
	case 0, 1:
		return n.Token.Pos()
	default:
		panic("internal error")
	}
}

// TypeDecl represents data reduced by productions:
//
//	TypeDecl:
//	        "type" '(' ')'                            // Case 0
//	|       "type" '(' TypeSpecList SemicolonOpt ')'  // Case 1
//	|       "type" TypeSpec                           // Case 2
type TypeDecl struct {
	Case         int
	SemicolonOpt *SemicolonOpt
	Token        xc.Token
	Token2       xc.Token
	Token3       xc.Token
	TypeSpec     *TypeSpec
	TypeSpecList *TypeSpecList
}

func (n *TypeDecl) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *TypeDecl) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *TypeDecl) Pos() token.Pos {
	if n == nil {
		return 0
	}

	return n.Token.Pos()
}

// TypeLiteral represents data reduced by productions:
//
//	TypeLiteral:
//	        '*' TypeLiteral  // Case 0
//	|       ArrayType        // Case 1
//	|       ChanType         // Case 2
//	|       FuncType         // Case 3
//	|       InterfaceType    // Case 4
//	|       MapType          // Case 5
//	|       SliceType        // Case 6
//	|       StructType       // Case 7
type TypeLiteral struct {
	ArrayType     *ArrayType
	Case          int
	ChanType      *ChanType
	FuncType      *FuncType
	InterfaceType *InterfaceType
	MapType       *MapType
	SliceType     *SliceType
	StructType    *StructType
	Token         xc.Token
	TypeLiteral   *TypeLiteral
}

func (n *TypeLiteral) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *TypeLiteral) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *TypeLiteral) Pos() token.Pos {
	if n == nil {
		return 0
	}

	switch n.Case {
	case 1:
		return n.ArrayType.Pos()
	case 2:
		return n.ChanType.Pos()
	case 3:
		return n.FuncType.Pos()
	case 4:
		return n.InterfaceType.Pos()
	case 5:
		return n.MapType.Pos()
	case 6:
		return n.SliceType.Pos()
	case 7:
		return n.StructType.Pos()
	case 0:
		return n.Token.Pos()
	default:
		panic("internal error")
	}
}

// TypeSpec represents data reduced by production:
//
//	TypeSpec:
//	        IDENTIFIER Type  // Case 0
type TypeSpec struct {
	ref
	typeScope *Scope
	Token     xc.Token
	Type      *Type
}

func (n *TypeSpec) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *TypeSpec) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *TypeSpec) Pos() token.Pos {
	if n == nil {
		return 0
	}

	return n.Token.Pos()
}

// TypeSpecList represents data reduced by productions:
//
//	TypeSpecList:
//	        TypeSpec                   // Case 0
//	|       TypeSpecList ';' TypeSpec  // Case 1
type TypeSpecList struct {
	Case         int
	Token        xc.Token
	TypeSpec     *TypeSpec
	TypeSpecList *TypeSpecList
}

func (n *TypeSpecList) reverse() *TypeSpecList {
	if n == nil {
		return nil
	}

	na := n
	nb := na.TypeSpecList
	for nb != nil {
		nc := nb.TypeSpecList
		nb.TypeSpecList = na
		na = nb
		nb = nc
	}
	n.TypeSpecList = nil
	return na
}

func (n *TypeSpecList) fragment() interface{} { return n.reverse() }

// String implements fmt.Stringer.
func (n *TypeSpecList) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *TypeSpecList) Pos() token.Pos {
	if n == nil {
		return 0
	}

	switch n.Case {
	case 0:
		return n.TypeSpec.Pos()
	case 1:
		return n.TypeSpecList.Pos()
	default:
		panic("internal error")
	}
}

// UnaryExpression represents data reduced by productions:
//
//	UnaryExpression:
//	        '!' UnaryExpression   // Case 0
//	|       '&' UnaryExpression   // Case 1
//	|       '*' UnaryExpression   // Case 2
//	|       '+' UnaryExpression   // Case 3
//	|       '-' UnaryExpression   // Case 4
//	|       '^' UnaryExpression   // Case 5
//	|       "<-" UnaryExpression  // Case 6
//	|       PrimaryExpression     // Case 7
type UnaryExpression struct {
	Case              int
	PrimaryExpression *PrimaryExpression
	Token             xc.Token
	UnaryExpression   *UnaryExpression
}

func (n *UnaryExpression) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *UnaryExpression) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *UnaryExpression) Pos() token.Pos {
	if n == nil {
		return 0
	}

	switch n.Case {
	case 7:
		return n.PrimaryExpression.Pos()
	case 0, 1, 2, 3, 4, 5, 6:
		return n.Token.Pos()
	default:
		panic("internal error")
	}
}

// VarDecl represents data reduced by productions:
//
//	VarDecl:
//	        "var" '(' ')'                           // Case 0
//	|       "var" '(' VarSpecList SemicolonOpt ')'  // Case 1
//	|       "var" VarSpec                           // Case 2
type VarDecl struct {
	Case         int
	SemicolonOpt *SemicolonOpt
	Token        xc.Token
	Token2       xc.Token
	Token3       xc.Token
	VarSpec      *VarSpec
	VarSpecList  *VarSpecList
}

func (n *VarDecl) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *VarDecl) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *VarDecl) Pos() token.Pos {
	if n == nil {
		return 0
	}

	return n.Token.Pos()
}

// VarSpec represents data reduced by productions:
//
//	VarSpec:
//	        IdentifierList '=' ExpressionList       // Case 0
//	|       IdentifierList Type                     // Case 1
//	|       IdentifierList Type '=' ExpressionList  // Case 2
type VarSpec struct {
	ref
	Case           int
	ExpressionList *ExpressionList
	IdentifierList *IdentifierList
	Token          xc.Token
	Type           *Type
}

func (n *VarSpec) fragment() interface{} { return n }

// String implements fmt.Stringer.
func (n *VarSpec) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *VarSpec) Pos() token.Pos {
	if n == nil {
		return 0
	}

	return n.IdentifierList.Pos()
}

// VarSpecList represents data reduced by productions:
//
//	VarSpecList:
//	        VarSpec                  // Case 0
//	|       VarSpecList ';' VarSpec  // Case 1
type VarSpecList struct {
	Case        int
	Token       xc.Token
	VarSpec     *VarSpec
	VarSpecList *VarSpecList
}

func (n *VarSpecList) reverse() *VarSpecList {
	if n == nil {
		return nil
	}

	na := n
	nb := na.VarSpecList
	for nb != nil {
		nc := nb.VarSpecList
		nb.VarSpecList = na
		na = nb
		nb = nc
	}
	n.VarSpecList = nil
	return na
}

func (n *VarSpecList) fragment() interface{} { return n.reverse() }

// String implements fmt.Stringer.
func (n *VarSpecList) String() string {
	return prettyString(n)
}

// Pos reports the position of the first component of n or zero if it's empty.
func (n *VarSpecList) Pos() token.Pos {
	if n == nil {
		return 0
	}

	switch n.Case {
	case 0:
		return n.VarSpec.Pos()
	case 1:
		return n.VarSpecList.Pos()
	default:
		panic("internal error")
	}
}
